// 정보처리기사 2024년 2회
export const SUBJECTS = [
  { id: 1, name: '소프트웨어 설계' },
  { id: 2, name: '소프트웨어 개발' },
  { id: 3, name: '데이터베이스 구축' },
  { id: 4, name: '프로그래밍 언어 활용' },
  { id: 5, name: '정보시스템 구축 관리' },
]

const questions = [
{
    id: 1,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: 'GoF(Gangs of Four) 디자인 패턴 중 생성 패턴으로 옳은 것은?',
    choices: ['Abstract Factory', 'Bridge', 'Observer', 'Composite'],
    answer: 1,
    explanation: '보기 중 생성 패턴은 추상 팩토리(Abstract Factory)입니다. 브리지(Bridge), 컴포지트(Composite)는 구조 패턴, 옵서버(Observer)는 행위 패턴입니다.',
  },
  {
    id: 2,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '소프트웨어 품질 관련 국제 표준인 ISO/IEC 25000의 특성이 아닌 것은?',
    choices: ['호환성', '보안성', '신뢰성', '반복성'],
    answer: 4,
    explanation: '반복성은 ISO/IEC 25000의 특성이 아닙니다. ISO/IEC 25000의 특성에는 기능성, 효율성, 호환성, 사용성, 신뢰성, 보안성, 유지 보수성, 이식성이 있습니다.',
  },
  {
    id: 3,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '캡슐화된 객체 내부의 자료 구조 또는 함수 이용이 외부에 영향을 받지 않기 위해 부작용을 최소화한 객체지향 개념은?',
    choices: ['Finding', 'Inheritance', 'Information Hiding', 'Polymorphism'],
    answer: 3,
    explanation: '문제에 제시된 내용은 정보 은닉(Information Hiding)의 개념입니다. 상속(Inheritance): 상위 클래스의 메소드와 속성을 하위 클래스가 물려받는 것을 의미함. 다형성(Polymorphism): 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미함',
  },
  {
    id: 4,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '요구공학 프로세스의 요구사항 개발 과정으로 옳지 않은 것은?',
    choices: ['요구사항 도출', '요구사항 구현', '요구사항 검증', '요구사항 분석'],
    answer: 2,
    explanation: '요구사항 구현은 요구사항 개발 과정이 아닙니다. 요구사항 개발 과정은 \'도출 → 분석 → 명세 → 확인(검증)\' 순으로 진행됩니다.',
  },
  {
    id: 5,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '요구사항 분석을 위해 리눅스에서 커널 버전을 확인하기 위한 명령어로 옳은 것은?',
    choices: ['pwd', 'ls', 'uname', 'mv'],
    answer: 3,
    explanation: '리눅스에서 현재 사용중인 커널 버전을 확인하는 명령은 uname입니다. ls: 현재 디렉터리 내의 파일 목록을 확인함. pwd: 현재 작업중인 디렉터리 경로를 화면에 출력함. mv: 파일을 이동시키거나 이름을 변경함',
  },
  {
    id: 6,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용되는 것은?',
    choices: ['Module', 'Component', 'Things', 'Prototype'],
    answer: 1,
    explanation: '모듈화를 통해 분리된 시스템의 각 기능들을 모듈(Module)이라고 합니다.',
  },
  {
    id: 7,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '다음 내용이 설명하는 UI 설계 도구는?\n- 디자인, 사용 방법 설명, 평가 등을 위해 실제 화면과 유사하게 만든 정적인 형태의 모형\n- 시각적으로만 구성 요소를 배치하는 것으로 일반적으로 실제로 구현되지는 않음',
    choices: ['스토리보드(Storyboard)', '목업(Mockup)', '프로토타입(Prototype)', '유스케이스(Usecase)'],
    answer: 2,
    explanation: '문제의 지문에 제시된 내용은 목업(Mockup)의 특징입니다. 스토리보드: 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서. 프로토타입: 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형. 유스케이스: 사용자 측면에서의 요구사항',
  },
  {
    id: 8,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스는?',
    choices: ['연관', '확장', '선택', '특전'],
    answer: 2,
    explanation: '특별한 조건을 만족할 때 수행할 유스케이스는 《extends》 연결하여 표현하는데, 이와 같이 연결되는 관계를 확장 관계라고 합니다.',
  },
  {
    id: 9,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '분산 시스템을 위한 마스터-슬레이브(Master-Slave) 아키텍처에 대한 설명으로 틀린 것은?',
    choices: ['일반적으로 실시간 시스템에서 사용된다.', '마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임진다.', '슬레이브 프로세스는 데이터 수집 기능을 수행할 수 없다.', '마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있다.'],
    answer: 3,
    explanation: '슬레이브 프로세스는 데이터 수집 기능을 수행할 수 있습니다. 슬레이브 프로세스에서는 마스터 프로세스에서 수행하는 연산, 통신, 제어 등의 기능을 제외하고는 별도로 제한되는 기능은 없습니다.',
  },
  {
    id: 10,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은?',
    choices: ['Inheritance', 'Class', 'Encapsulation', 'Association'],
    answer: 3,
    explanation: '속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은 캡슐화(Encapsulation)입니다. Inheritance(상속): 상위 클래스의 메소드의 속성을 하위 클래스가 물려받는 것을 의미함. Class: 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입(Type)을 의미함. Association(연관): 2개 이상의 사물이 서로 관련되어 있음',
  },
  {
    id: 11,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '다음 내용이 설명하는 객체지향 설계 원칙은?\n- 클라이언트는 자신이 사용하지 않는 메소드와 의존 관계를 맺으면 안 된다.\n- 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안 된다.',
    choices: ['분리 원칙', '책임 원칙', '개방 폐쇄의 원칙', '교체의 원칙'],
    answer: 1,
    explanation: '문제의 지문에 제시된 내용은 객체지향 설계 원칙 중 인터페이스 분리 원칙에 대한 설명입니다. 단일 책임 원칙(SRP; Single Responsibility Principle): 객체는 단 하나의 책임만 가져야 한다는 원칙. 개방-폐쇄 원칙(OCP; Open-Closed Principle): 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙. 리스코프 치환 원칙(LSP; Liskov Substitution Principle): 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙',
  },
  {
    id: 12,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '다음 중 비기능 요구사항에 대한 설명으로 좋은 것은?',
    choices: [
      '은행의 조회, 입금, 출금, 이체 등이 어떻게 수행되는지 여부는 비기능 요구사항에 해당한다.',
      '처리 속도 및 시간, 처리량 등의 성능에 대한 요구사항은 비기능 요구사항에 해당하지 않는다.',
      '보안 및 접근 통제를 위한 요구사항은 비기능 요구사항에 해당하지 않는다.',
      '"차량 대여 시스템에서 제공하는 모든 화면은 3초 안에 사용자에게 보여야 한다"는 것은 비기능 요구사항에 해당한다.',
    ],
    answer: 4,
    explanation: '비기능 요구사항에 대한 설명으로 옳은 것은 ④번입니다. ①번은 시스템이 수행해야 하는 기능에 대한 것으로 기능 요구사항입니다. ②, ③번은 성능에 관한 비기능 요구사항입니다. ④번은 보안에 관한 비기능 요구사항입니다.',
  },
  {
    id: 13,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '사용자 인터페이스(User Interface)에 대한 설명으로 틀린 것은?',
    choices: [
      '사용자와 시스템이 정보를 주고받는 상호작용이 잘 이루어지도록 하는 장치나 소프트웨어를 의미한다.',
      '편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.',
      '배우기가 용이하고 쉽게 사용할 수 있도록 만들어져야 한다.',
      '사용자 요구사항이 UI에 반영될 수 있도록 구성해야 한다.',
    ],
    answer: 2,
    explanation: '사용자 인터페이스(UI)는 사용자가 쉽게 이해하고 편리하게 사용할 수 있도록 사용자 중심으로 설계되어야 합니다.',
  },
  {
    id: 14,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '애자일(Agile) 기법 중 스크럼(Scrum)과 관련된 용어에 대한 설명이 틀린 것은?',
    choices: [
      '스크럼 마스터(Scrum Master)는 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡는다.',
      '제품 백로그(Product Backlog)는 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함될 수 있다.',
      '스프린트(Sprint)는 하나의 완성된 최종 결과물을 만들기 위한 주기로 3달 이상의 장기간으로 결정된다.',
      '속도(Velocity)는 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있다.',
    ],
    answer: 3,
    explanation: '스프린트는 실제 개발 작업을 진행하는 과정으로, 보통 2~4주 정도의 기간 내에서 진행합니다.',
  },
  {
    id: 15,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '다음 중 객체지향 설계 원칙에 속하지 않는 것은?',
    choices: [
      '개방-폐쇄 원칙(OCP; Open-Closed Principle)',
      '의존 역전 원칙(DIP; Dependency Inversion Principle)',
      '인터페이스 통합 원칙(IIP; Interface Integration Principle)',
      '단일 책임 원칙(SRP; Single Responsibility Principle)',
    ],
    answer: 3,
    explanation: '객체지향 설계 원칙 중 하나는 인터페이스 통합 원칙이 아니라 인터페이스 분리 원칙입니다.',
  },
  {
    id: 16,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '순차 다이어그램(Sequence Diagram)과 관련된 설명으로 틀린 것은?',
    choices: [
      '주로 정적인 측면에서 모델링을 설계하기 위해 사용한다.',
      '시간의 흐름에 따라 객체들이 주고 받는 메시지의 전달 과정을 강조한다.',
      '수직 방향이 시간의 흐름을 나타낸다.',
      '구성 요소에는 회귀 메시지, 제어 블록 등이 있다.',
    ],
    answer: 1,
    explanation: '순차 다이어그램은 주로 동적인 측면에서 모델링을 설계하기 위해 사용합니다.',
  },
  {
    id: 17,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어를 말하는 것은?',
    choices: ['EAI', 'FEP', 'GPL', 'Duplexing'],
    answer: 2,
    explanation: '문제에 제시된 내용은 전처리기(FEP; Front End Processor)의 개념입니다. EAI(Enterprise Application Integration): 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션. GPL(General Public License): 자유 소프트웨어 재단에서 만든 자유 소프트웨어 라이선스. Duplexing: 서비스 중단에 대비하여 동일한 기능을 수행하는 예비 시스템을 동시에 운영하는 것',
  },
  {
    id: 18,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '익스트림 프로그래밍에 대한 설명으로 틀린 것은?',
    choices: [
      '대표적인 구조적 방법론 중 하나이다.',
      '소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.',
      '익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다.',
      '구체적인 실천 방법을 정의하고 있으며, 개발 문서보다는 소스 코드에 중점을 둔다.',
    ],
    answer: 1,
    explanation: '익스트림 프로그래밍(eXtreme Programming)은 애자일 개발 방법론을 기반으로 하는 소프트웨어 개발 모형입니다.',
  },
  {
    id: 19,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '자료 흐름도(DFD)의 각 요소별 표기 형태의 연결이 옳지 않은 것은?',
    choices: ['Process: 원', 'Data Flow: 화살표', 'Data Store: 삼각형', 'Terminator: 사각형'],
    answer: 3,
    explanation: '자료 저장소(Data Store)는 평행선(=)으로 기입합니다.',
  },
  {
    id: 20,
    subject: 1,
    subjectName: '소프트웨어 설계',
    question: '유스케이스(Usecase)에 대한 설명 중 옳은 것은?',
    choices: [
      '유스케이스 다이어그램은 개발자의 요구를 추출하고 분석하기 위해 주로 사용한다.',
      '액터는 대상 시스템과 상호 작용하는 사람이나 다른 시스템에 의한 역할이다.',
      '사용자 액터는 본 시스템과 데이터를 주고받는 연동 시스템을 의미한다.',
      '연동의 개념은 일방적으로 데이터를 파일이나 정해진 형식으로 넘겨주는 것을 의미한다.',
    ],
    answer: 2,
    explanation: '유스케이스에 대한 설명 중 옳은 것은 ②번입니다. ① 유스케이스 다이어그램은 추출된 사용자의 요구를 분석하는 데 사용합니다. ③ 사용자 액터(주액터)는 시스템을 사용함으로써 이득을 얻는 대상을 의미합니다. 본 시스템과 데이터를 주고받는 연동 시스템을 시스템 액터(부액터)라고 합니다. ④ 연동은 2개 이상의 시스템이 일방이 아닌 상호 간의 동작에 영향을 줄 수 있도록 연결망을 구성하는 것을 의미합니다.',
  },
  {
    id: 21,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '다음 중 커버리지의 종류가 아닌 것은?',
    choices: ['구문 커버리지', '결정 커버리지', '조건 커버리지', '강도 커버리지'],
    answer: 4,
    explanation: '강도 커버리지는 커버리지의 종류가 아닙니다. 커버리지의 종류에는 구문 커버리지(Statement Coverage), 결정 커버리지(Decision Coverage), 조건 커버리지(Condition Coverage), 조건/결정 커버리지(Condition/Decision Coverage) 등이 있습니다.',
  },
  {
    id: 22,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '다음 자료에 대하여 선택(Selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다. 2회전 수행 결과는?\n\n초기상태: 27, 1, 4, 30, 7',
    choices: ['1, 27, 4, 30, 7', '1, 4, 27, 30, 7', '1, 4, 7, 27, 30', '1, 4, 7, 30, 27'],
    answer: 2,
    explanation: '선택 정렬은 n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지에서 다시 최소값을 찾아 교환하는 방식입니다.\n- 원본: 27, 1, 4, 30, 7\n- 1회전: 중 최소값 1을 찾아 첫 번째 값 27과 교환 → 1, 27, 4, 30, 7\n- 2회전: 나머지 중 최소값 4를 찾아 두 번째 값 27과 교환 → 1, 4, 27, 30, 7',
  },
  {
    id: 23,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '소프트웨어 프로젝트 관리에 대한 설명으로 가장 옳은 것은?',
    choices: [
      '개발에 따른 산출물 관리',
      '소요인력은 최대화하되 정책 결정은 신속하게 처리',
      '주어진 기간은 연장하되 최소의 비용으로 시스템을 개발',
      '주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발',
    ],
    answer: 4,
    explanation: '프로젝트 관리(Project Management)는 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동입니다.',
  },
  {
    id: 24,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '다음과 같은 중위식(Infix)을 후위식(Postfix)으로 올바르게 표현한 것은?\n\nA/B*(C+D)+E',
    choices: ['+*/AB+CDE', 'CD+AB/*E+', '/*++ABCDE', 'AB/CD+*E+'],
    answer: 4,
    explanation: '중위식(Infix)을 후위식(Postfix)으로 표현하려면 연산자의 우선순위에 따라 괄호를 묶고 해당 괄호의 뒤(오른쪽)로 연산자를 옮기면 됩니다.\n- 연산 우선순위에 따라 괄호로 묶습니다: ((A/B)*(C+D))+E\n- 연산자를 해당 괄호의 뒤로 옮깁니다: ((AB/)(CD+)*)+E → AB/CD+*E+',
  },
  {
    id: 25,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '명세 기반 테스트 중 프로그램의 입력 조건에 중점을 두고, 어느 하나의 입력 조건에 대하여 타당한 값과 그렇지 못한 값을 설정하여 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 테스트 기법은?',
    choices: ['Cause-Effect Graphing Testing', 'Equivalence Partitioning Testing', 'Boundary Value Analysis', 'Comparison Testing'],
    answer: 2,
    explanation: '문제에 제시된 내용은 동치 분할 검사(Equivalence Partitioning Testing)에 대한 설명입니다.\n- 원인-효과 그래프 검사(Cause-Effect Graphing Testing): 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법\n- 경계값 분석(Boundary Value Analysis): 입력 자료에만 치중한 동치 분할 기법을 보완하기 위한 기법으로, 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사함\n- 비교 검사(Comparison Testing): 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법',
  },
  {
    id: 26,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '하향식 통합에 있어서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 무엇이라고 하는가?',
    choices: ['Stub', 'Driver', 'Procedure', 'Function'],
    answer: 1,
    explanation: '하향식 통합 테스트에서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 스텁(Stub)이라고 합니다.\n- 드라이버(Driver): 테스트 대상의 하위 모듈을 호출하는 도구로, 매개 변수(Parameter)를 전달하고, 모듈 테스트 수행 후의 결과를 도출함',
  },
  {
    id: 27,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것은?',
    choices: ['Refactoring', 'Architecting', 'Specification', 'Renewal'],
    answer: 1,
    explanation: '소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것을 리팩토링(Refactoring)이라고 합니다.',
  },
  {
    id: 28,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '디지털 저작권 관리(DRM)의 기술 요소가 아닌 것은?',
    choices: ['크랙 방지 기술', '정책 관리 기술', '암호화 기술', '방화벽 기술'],
    answer: 4,
    explanation: '디지털 저작권 관리(DRM)의 기술 요소에는 암호화, 키 관리, 암호화 파일 생성, 식별 기술, 저작권 표현, 정책 관리, 크랙 방지, 인증 등이 있습니다.\n- 방화벽 기술: 기업이나 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용·거부·수정하는 기능을 가진 침입 차단 시스템',
  },
  {
    id: 29,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '소프트웨어 모듈화의 장점이 아닌 것은?',
    choices: [
      '오류의 파급 효과를 최소화한다.',
      '기능의 분리가 가능하여 인터페이스가 복잡하다.',
      '모듈의 재사용 가능으로 개발과 유지보수가 용이하다.',
      '프로그램의 효율적인 관리가 가능하다.',
    ],
    answer: 2,
    explanation: '모듈화의 장점은 기능의 분리가 가능하여 인터페이스가 단순해지는 것입니다.',
  },
  {
    id: 30,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '정형 기술 검토(FTR)의 지침 사항으로 옳은 내용 모두를 나열한 것은?\n```\nㄱ. 의제를 제한한다.\nㄴ. 논쟁과 반박을 제한한다.\nㄷ. 문제 영역을 명확히 표현한다.\nㄹ. 참가자의 수를 제한하지 않는다.\n```',
    choices: ['ㄱ, ㄷ', 'ㄱ, ㄴ, ㄷ', 'ㄱ, ㄴ, ㄹ', 'ㄱ, ㄴ, ㄷ, ㄹ'],
    answer: 2,
    explanation: '정형 기술 검토(FTR)의 지침 사항으로 옳은 내용 모두를 나열한 것은 ②번입니다. 정형 기술 검토는 의제와 참가자의 수를 제한합니다.',
  },
{
    id: 31,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '블랙 박스 검사에 관하여 기술한 것 중 잘못된 것은?',
    choices: [
      '모듈의 구조보다 기능을 검사한다.',
      '동치 분할(Equivalence Partitioning)이라는 기법을 사용한다.',
      'Nassi-Shneiderman 도표를 사용하여 검정 기준을 작성할 수 있다.',
      '원인-결과 그래프(Cause and Effect Graph)로 테스트 케이스를 작성할 수 있다.',
    ],
    answer: 3,
    explanation: 'N-S 차트를 이용하여 검정 기준을 작성할 수 있는 것은 화이트박스 검사입니다.',
  },
  {
    id: 32,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법은?',
    choices: [
      '단위 테스트',
      '인수 테스트',
      '시스템 테스트',
      '통합 테스트',
    ],
    answer: 2,
    explanation: '개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법은 인수 테스트(Acceptance Test)라고 합니다.\n- 단위 테스트(Unit Test): 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에서 초점을 맞춰 하는 테스트\n- 시스템 테스트(System Test): 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트\n- 통합 테스트(Integration Test): 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트',
  },
  {
    id: 33,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성·값의 쌍 형태로 표현하는 형식으로, 자바 스크립트(JavaScript)를 토대로 개발되어진 형식은?',
    choices: [
      'Python',
      'XML',
      'JSON',
      'WEB SERVER',
    ],
    answer: 3,
    explanation: '문제에 제시된 내용은 JSON(JavaScript Object Notation)에 대한 설명입니다.\n- 파이썬(Python): 객체지향 기능을 지원하는 대화형 인터프리터 언어로, 플랫폼에 독립적이고 문법이 간단하여 배우기 쉬움\n- XML(eXtensible Markup Language): 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어\n- 웹 서버(Web Server): 클라이언트로부터 직접 요청을 받아 처리하는 서버로, 저용량의 정적 파일들을 제공함',
  },
  {
    id: 34,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '다음 중 인터페이스 구현 검증 도구에 대한 설명으로 옳지 않은 것은?',
    choices: [
      'STAF: Ruby를 사용하는 애플리케이션 테스트 프레임워크이다.',
      'xUnit: NUnit, JUnit 등 다양한 언어를 지원하는 단위 테스트 프레임워크이다.',
      'FitNesse: 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다.',
      'NTAF: Naver의 테스트 자동화 프레임워크로, FitNesse와 STAF를 통합하였다.',
    ],
    answer: 1,
    explanation: 'STAF는 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크입니다. ①번은 watir에 대한 설명입니다.',
  },
  {
    id: 35,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 프로그램을 의미하는 것은?',
    choices: [
      'Title Code',
      'Source Code',
      'Object Code',
      'Alien Code',
    ],
    answer: 4,
    explanation: '아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 외계인 코드(Alien Code)라고 합니다.',
  },
  {
    id: 36,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '제어 흐름 그래프가 다음과 같을 때 McCabe의 Cyclomatic 수는 얼마인가?\n\n(간선 수 = 6, 노드 수 = 4)',
    choices: [
      '3',
      '4',
      '5',
      '6',
    ],
    answer: 2,
    explanation: '제어 흐름도에서 순환복잡도(Cyclomatic)는 다음과 같이 2가지 방법으로 계산할 수 있습니다.\n- [방법 1] 영역 수 계산: 내부 영역 3개 + 외부 영역 1개 = 4\n- [방법 2] V(G) = E - N + 2 (E는 화살표 수, N은 노드 수): V(G) = 6 - 4 + 2 = 4',
  },
  {
    id: 37,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '소프트웨어 공학에서 워크스루(Walkthrough)에 대한 설명으로 틀린 것은?',
    choices: [
      '사용사례를 확장하여 명세하거나 설계 다이어그램, 원시 코드, 테스트 케이스 등에 적용할 수 있다.',
      '복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.',
      '인스펙션(Inspection)과 동일한 의미를 가진다.',
      '단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것이다.',
    ],
    answer: 3,
    explanation: '인스펙션(Inspection)은 워크스루를 발전시킨 형태로, 소프트웨어 개발 단계에서 산출된 결과물의 품질을 평가하고 이를 개선하기 위한 방법 등을 제시합니다.',
  },
  {
    id: 38,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?',
    choices: [
      'Portability',
      'Efficiency',
      'Usability',
      'Correctness',
    ],
    answer: 1,
    explanation: '하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 이식성(Portability)이라고 합니다.',
  },
  {
    id: 39,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '소프트웨어 생명주기 모델 중 V 모델과 관련한 설명으로 틀린 것은?',
    choices: [
      '요구 분석 및 설계 단계를 거치지 않으며 항상 통합 테스트를 중심으로 V 형태를 이룬다.',
      'Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적이다.',
      '개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있다.',
      '폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둔다.',
    ],
    answer: 1,
    explanation: '소프트웨어 생명 주기의 V-모델은 \'요구사항 → 분석 → 설계 → 구현\' 단계로 수행되며 각 단계를 테스트와 연결하여 표현합니다.',
  },
  {
    id: 40,
    subject: 2,
    subjectName: '소프트웨어 개발',
    question: '다음 트리를 전위 순회(Preorder Traversal)한 결과는?\n\n(트리 구조: 루트 +, 좌측 *, 우측 E, *의 좌측 /, *의 우측 D, /의 좌측 A, /의 우측 B, D의 좌측 C)',
    choices: [
      '+*AB/*CDE',
      'AB/C*D*E+',
      'A/B*C*D+E',
      '+**/ABCDE',
    ],
    answer: 4,
    explanation: '먼저 서브 트리를 하나의 노드로 생각할 수 있도록 서브 트리 단위로 묶습니다. Preorder는 Root → Left → Right이므로 +*E입니다. 1은 *2D이므로 +*2DE입니다. 2는 *3C이므로 ++*3CDE입니다. 3은 /AB이므로 +**/ABCDE입니다.',
  },
  {
    id: 41,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '주어진 속성의 값이 하나의 속성이 취할 수 있는 같은 타입의 모든 원자값들의 집합에 속한 값이어야 한다는 제약 조건은?',
    choices: [
      '기본키 제약 조건',
      '외래키 제약 조건',
      '도메인 제약 조건',
      '키 제약 조건',
    ],
    answer: 3,
    explanation: '문제에 제시된 내용은 도메인 제약 조건에 대한 설명입니다.',
  },
  {
    id: 42,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '관계형 데이터 모델의 릴레이션에 대한 설명으로 틀린 것은?',
    choices: [
      '모든 속성 값은 원자 값을 갖는다.',
      '한 릴레이션에 포함된 튜플은 모두 상이하다.',
      '한 릴레이션에 포함된 튜플 사이에는 순서가 없다.',
      '한 릴레이션을 구성하는 속성 사이에는 순서가 존재한다.',
    ],
    answer: 4,
    explanation: '릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않으며, 특별한 순서가 없습니다.',
  },
  {
    id: 43,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '시스템 카탈로그에 대한 설명으로 옳지 않은 것은?',
    choices: [
      '시스템 카탈로그에 저장된 정보를 슈퍼 데이터(Super Data)라고 한다.',
      '시스템 자신이 필요로 하는 스키마 및 여러 가지 객체에 관한 정보를 포함하고 있는 시스템 데이터베이스이다.',
      '카탈로그들이 생성되면 자료 사전에 저장되기 때문에 좁은 의미로 자료사전이라고 한다.',
      '시스템 카탈로그에 대한 사용자의 접근은 읽기 전용으로만 허용된다.',
    ],
    answer: 1,
    explanation: '시스템 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 합니다.',
  },
  {
    id: 44,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '3NF에서 BCNF가 되기 위한 조건은?',
    choices: [
      '이행적 함수 종속 제거',
      '부분적 함수 종속 제거',
      '다치 종속 제거',
      '결정자이면서 후보키가 아닌 것 제거',
    ],
    answer: 4,
    explanation: '제3정규형(3NF)에서 BCNF로 정규화하기 위해서는 모든 결정자가 후보키가 될 수 있도록 결정자가 후보키가 아닌 것을 제거해야 합니다.',
  },
  {
    id: 45,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '다음 그래프의 인접 행렬(Adjacency Matrix) 표현 시 옳은 것은?\n\n방향 그래프에서 0은 방향 간선이 없는 것이고, 1이 있는 곳은 1→3, 1→2, 2→3→1',
    choices: [
      '[[0,1,1],[0,0,1],[1,0,0]]',
      '[[0,1,1],[0,1,1],[1,0,0]]',
      '[[0,0,1],[0,0,1],[1,0,1]]',
      '[[1,0,1],[0,1,0],[1,0,1]]',
    ],
    answer: 1,
    explanation: '방향성 그래프에서 0은 방향 간선이 없는 것이고, 1이 있는 곳은 1→3, 1→2, 2→3→1입니다. 이를 행렬로 표현하면 ①입니다.',
  },
  {
    id: 46,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '데이터 모델의 구성 요소가 아닌 것은?',
    choices: [
      '추상적인 개념으로 조직된 구조',
      '구성 요소의 연산',
      '구성 요소의 제약 조건',
      '구성 요소들의 저장 인터페이스',
    ],
    answer: 4,
    explanation: '데이터 모델의 구성 요소에는 구조(Structure), 연산(Operation), 제약 조건(Constraint)이 있습니다.',
  },
  {
    id: 47,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은?',
    choices: [
      '저장 레코드 양식 설계',
      '레코드 집중의 분석 및 설계',
      '접근 경로 설계',
      '목표 DBMS에 맞는 스키마 설계',
    ],
    answer: 4,
    explanation: '④번은 논리적 설계 단계에서 수행하는 사항입니다.',
  },
  {
    id: 48,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '정규화 과정에서 발생하는 이상(Anomaly)에 관한 설명으로 옳지 않은 것은?',
    choices: [
      '이상은 속성들 간에 존재하는 여러 종류의 종속 관계를 하나의 릴레이션에 표현할 때 발생한다.',
      '속성들 간의 종속 관계를 분석하여 여러 개의 릴레이션을 하나로 결합하여 이상을 해결한다.',
      '삭제 이상, 삽입 이상, 갱신 이상이 있다.',
      '정규화는 이상을 제거하기 위하여 중복성 및 종속성을 배제시키는 방법으로 사용한다.',
    ],
    answer: 2,
    explanation: '이상을 해결하기 위해 정규화를 수행하는데, 정규화는 속성들 간의 종속 관계를 분석하여 한 개의 릴레이션을 여러 개의 릴레이션으로 분해합니다.',
  },
  {
    id: 49,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '사용자 X1에게 department 테이블에 대한 검색 연산을 회수하는 명령은?',
    choices: [
      'delete select on department to X1;',
      'remove select on department from X1;',
      'revoke select on department from X1;',
      'grant select on department from X1;',
    ],
    answer: 3,
    explanation: '사용자로부터 권한을 취소(회수)하는 명령어는 revoke입니다. revoke select on department from X1; → 검색(select) 권한을 취소하라, (department) 테이블에 대한 권한을 취소하라, 사용자 \'X1\'에 대한 권한을 취소하라.',
  },
  {
    id: 50,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '관계대수에 대한 설명으로 틀린 것은?',
    choices: [
      '원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어이다.',
      '릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모두 릴레이션이다.',
      '일반 집합 연산과 순수 관계 연산으로 구분된다.',
      '질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.',
    ],
    answer: 1,
    explanation: '①번은 관계해석에 대한 설명입니다.',
  },
  {
    id: 51,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '다음 R과 S 두 릴레이션에 대한 Division 연산의 수행 결과는?\n\nR 테이블: (D1,D2,D3) = (a,1,A),(b,1,A),(c,2,A),(d,2,B)\nS 테이블: (D2,D3) = (1,A)',
    choices: [
      'D1: a',
      'D1: b',
      'D1: c, d',
      'D1: a, b',
    ],
    answer: 4,
    explanation: 'X÷Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산을 Division이라고 합니다.',
  },
  {
    id: 52,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?',
    choices: [
      '데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.',
      '로킹 단위가 작아지면 로킹 오버헤드가 증가한다.',
      '한꺼번에 로킹할 수 있는 단위를 로킹 단위라고 한다.',
      '로킹 단위가 작아지면 병행성 수준이 낮아진다.',
    ],
    answer: 4,
    explanation: '로킹 단위가 작아지면 병행성 수준이 높아지고, 데이터베이스 공유도가 증가합니다.',
  },
  {
    id: 53,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '다음 중 SQL의 집계 함수(Aggregation Function)가 아닌 것은?',
    choices: [
      'AVG',
      'COUNT',
      'SUM',
      'CREATE',
    ],
    answer: 4,
    explanation: '속성의 값을 집계할 때 사용하는 집계(그룹) 함수에는 COUNT, SUM, AVG, MAX, MIN 등이 있습니다. CREATE는 테이블이나 뷰를 생성하는 DDL 명령어입니다.',
  },
  {
    id: 54,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 경우 애트리뷰트 X의 값 각각에 대해 시간에 관계없이 항상 애트리뷰트 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속이라고 한다. 이 함수 종속의 표기로 옳은 것은?',
    choices: [
      'Y→X',
      'Y⊂X',
      'X→Y',
      'X⊂Y',
    ],
    answer: 3,
    explanation: 'X가 Y를 함수적으로 종속할 때 X → Y로 표기합니다.',
  },
  {
    id: 55,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '파티셔닝 방식 중 \'월별, 분기별\'과 같이 지정한 열의 값을 기준으로 범위를 지정하여 분할하는 방식은?',
    choices: [
      'Range Partitioning',
      'Hash Partitioning',
      'Composite Partitioning',
      'List Partitioning',
    ],
    answer: 1,
    explanation: '지정한 열의 값을 기준으로 범위를 지정하여 분할하는 방식은 범위 분할(Range Partitioning)입니다.',
  },
  {
    id: 56,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '관계대수의 순수 관계 연산자가 아닌 것은?',
    choices: [
      'Select',
      'Cartesian Product',
      'Division',
      'Project',
    ],
    answer: 2,
    explanation: '순수 관계 연산자에는 Select, Project, Join, Division이 있습니다. Cartesian Product(교차곱)는 일반 집합 연산자입니다.',
  },
  {
    id: 57,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: 'DELETE 명령에 대한 설명으로 틀린 것은?',
    choices: [
      '테이블의 행을 삭제할 때 사용한다.',
      'WHERE 조건절이 없는 DELETE 명령을 수행하면 DROP TABLE 명령을 수행했을 때와 동일한 효과를 얻을 수 있다.',
      'SQL을 사용 용도에 따라 분류한 경우 DML에 해당한다.',
      '기본 사용 형식은 "DELETE FROM 테이블 [WHERE 조건];"이다.',
    ],
    answer: 2,
    explanation: 'DROP은 테이블을 삭제하고, DELETE는 레코드를 삭제하는 명령어입니다. DELETE에 WHERE 조건을 넣지 않으면 테이블은 남아있고 테이블 안에 있는 모든 레코드가 삭제됩니다.',
  },
  {
    id: 58,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: 'E-R 모델의 표현 방법으로 옳지 않은 것은?',
    choices: [
      '개체 타입: 사각형',
      '관계 타입: 마름모',
      '속성: 오각형',
      '연결: 선',
    ],
    answer: 3,
    explanation: 'E-R 모델에서 속성은 타원으로 표현합니다.',
  },
  {
    id: 59,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '테이블 R과 S에 대한 다음의 SQL문이 실행되었을 때, 실행 결과로 옳은 것은?\n\nR: (A,B) = (1,A),(3,B)\nS: (A,B) = (1,A),(2,B)\nSQL: SELECT A FROM R UNION ALL SELECT A FROM S;',
    choices: [
      '1, 3',
      '1, 2',
      '1, 2, 3',
      '1, 3, 1, 2',
    ],
    answer: 4,
    explanation: 'SQL문의 실행 결과로 옳은 것은 ④번입니다. 문제에 제시된 질의문은 집합 연산자 UNION ALL을 이용한 통합 질의로, 여러 테이블의 필드 값을 통합하여 표시하되 중복된 레코드도 그대로 표시합니다.',
  },
  {
    id: 60,
    subject: 3,
    subjectName: '데이터베이스 구축',
    question: '뷰(VIEW)에 대한 설명으로 옳지 않은 것은?',
    choices: [
      'DBA는 보안 측면에서 뷰를 활용할 수 있다.',
      '뷰 위에 또 다른 뷰를 정의할 수 있다.',
      '뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다.',
      '독립적인 인덱스를 가질 수 없다.',
    ],
    answer: 3,
    explanation: '뷰는 기본 테이블이나 또 다른 뷰를 이용해서 만든 가상 테이블로서, 기본 테이블과 비교할 때 삽입, 삭제, 갱신 연산에 제약이 있습니다.',
  },
{
    id: 61,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: 'HTTP의 잘 알려진(Well Known) 포트 번호는?',
    choices: ['23', '80', '53', '443'],
    answer: 2,
    explanation: 'HTTP의 잘 알려진(Well Known) 포트 번호는 80입니다.',
  },
  {
    id: 62,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: 'C 언어에서 다음과 같은 구조체를 정의해서 사용할 경우 구조체 bit_field의 크기는 몇 바이트인가?\n```c\nstruct bit_field {\n    unsigned char a : 2;\n    unsigned char b : 3;\n    unsigned char c : 4;\n};\n```',
    choices: ['2', '3', '4', '5'],
    answer: 1,
    explanation: '구조체 bit_field의 크기는 2Byte입니다. 구조체 bit_field의 변수들이 모두 unsigned char이므로 메모리 공간을 1Byte 단위로 확보합니다. 변수 a, b, c를 모두 합하면 총 9비트인데, 메모리 공간을 1Byte 단위로 확보하므로, 총 2Byte가 할당됩니다.',
  },
  {
    id: 63,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '다음 파이썬으로 구현된 프로그램의 실행 결과로 옳은 것은?\n```python\nk1=["bob","and","cho","tom","jessy"]\nk2=k1\ndel(k2[3])\nprint(k1)\n```',
    choices: ['[\'bob\']', '[\'bob\', \'and\', \'cho\']', '[\'bob\', \'and\', \'cho\', \'jessy\']', '[\'bob\', \'and\', \'cho\', \'tom\', \'jessy\']'],
    answer: 3,
    explanation: '코드의 실행 결과로 옳은 것은 ③번입니다. k1을 k2에 할당하면, k1과 k2는 동일한 리스트 객체를 참조하게 됩니다. del(k2[3])으로 k2의 네 번째 요소 \'tom\'을 삭제하면 k1에도 적용됩니다. 결과: [\'bob\', \'and\', \'cho\', \'jessy\']',
  },
  {
    id: 64,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '다음은 키보드로 숫자를 입력받아 홀수인지 짝수인지 판별하여 출력하는 코드를 C 언어로 구현한 것이다. 괄호(①, ②)에 순서대로 들어갈 내용으로 알맞은 것은?\n```c\n#include <stdio.h>\nint num;\nscanf("%d", &num);\nif (num (①) (②) :\n    printf("홀수입니다.\\n");\n(①), else\n    printf("짝수입니다.\\n");\n```',
    choices: ['%, else', '%, else if', '/, else', '/, else if'],
    answer: 1,
    explanation: '괄호(①, ②)에 순서대로 들어갈 내용은 %, else입니다. num을 2로 나눈 나머지가 1이면 홀수, 아니면 짝수입니다.',
  },
  {
    id: 65,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '다음 파이썬으로 구현된 프로그램의 실행 결과로 옳은 것은?\n```python\nk="Hello Python Programming Language"\na=k.split()\nb=a[1:3:5]\nprint(b)\n```',
    choices: ['[\'Hello\']', '[\'Python\']', '[\'Programming\']', '[\'Language\']'],
    answer: 2,
    explanation: 'k를 공백 기준으로 분리하면 a = [\'Hello\', \'Python\', \'Programming\', \'Language\']. b=a[1:3:5]에서 증가값이 5인데, a의 1번째 위치에서 2(3-1)번째 위치까지 5씩 증가하면서 가져오면 a의 1번째 위치의 값만 가져옵니다. 결과: [\'Python\']',
  },
  {
    id: 66,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '다음 파이썬으로 구현된 프로그램의 실행 결과로 옳은 것은?\n```python\ne = [10 * i for i in range(10) if i % 2 == 0]\nprint(e)\n```',
    choices: ['[0, 2, 4, 6, 8]', '[0, 1, 3, 5, 7, 9]', '[0, 20, 40, 60, 80]', '[0, 10, 30, 50, 70, 90]'],
    answer: 3,
    explanation: '리스트 e를 선언하고 i가 0부터 9까지 증가하면서 i를 2로 나눈 나머지가 0인 경우에만 \'10*i\'를 수행한 값으로 초기화합니다. i가 0, 2, 4, 6, 8일 경우에만 조건이 참이므로, 이때의 \'10*i\'의 값인 0, 20, 40, 60, 80으로 e가 초기화됩니다. 결과: [0, 20, 40, 60, 80]',
  },
  {
    id: 67,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '자바에서 사용하는 접근 제어자의 종류가 아닌 것은?',
    choices: ['Internal', 'Private', 'Protected', 'Public'],
    answer: 1,
    explanation: 'Internal은 자바에서 사용하는 접근 제어자가 아닙니다. JAVA의 접근 제어자에는 Public, Default, Private, Protected 등이 있습니다.',
  },
  {
    id: 68,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '3개의 페이지 프레임(Frame)을 가진 기억장치에서 페이지 요청을 다음과 같은 페이지 번호 순으로 요청했을 때 교체 알고리즘으로 FIFO 방법을 사용한다면 몇 번의 페이지 부재(Fault)가 발생하는가?\n(단, 현재 기억장치는 모두 비어 있다고 가정한다.)\n요청된 페이지 번호의 순서: 2, 3, 2, 1, 5, 2, 4, 5, 3, 2, 5, 2',
    choices: ['7번', '8번', '9번', '10번'],
    answer: 3,
    explanation: '페이지 부재 횟수는 9번입니다. FIFO 기법은 각각의 페이지가 주기억장치에 적재될 때마다 그 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체합니다.',
  },
  {
    id: 69,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '선점 스케줄링과 비선점 스케줄링에 대한 비교 설명 중 옳은 것은?',
    choices: ['선점 스케줄링은 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없다.', '선점 스케줄링은 상대적으로 과부하가 적다.', '비선점 스케줄링은 시분할 시스템에 유용하다.', '비선점 스케줄링은 응답시간의 예측이 용이하다.'],
    answer: 4,
    explanation: '선점 스케줄링과 비선점 스케줄링에 대한 비교 설명 중 옳은 것은 ④번입니다. ① 선점 스케줄링은 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 있습니다. ② 선점 스케줄링은 강제로 CPU를 빼앗아 사용할 수 있으므로 과부하가 많이 발생합니다. ③ 비선점 스케줄링은 일괄 처리 시스템에 유용하고, 선점 스케줄링이 시분할 시스템에 유용합니다.',
  },
  {
    id: 70,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '다음 중 가장 강한 응집도(Cohesion)는?',
    choices: ['Sequential Cohesion', 'Procedural Cohesion', 'Logical Cohesion', 'Coincidental Cohesion'],
    answer: 1,
    explanation: '보기 중 가장 강한 응집도는 Sequential Cohesion입니다.',
  },
  {
    id: 71,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '트랜잭션의 특성 중 트랜잭션 내의 모든 연산은 반드시 한꺼번에 완료되어야 하며, 그렇지 못한 경우는 한꺼번에 취소되어야 한다는 것은?',
    choices: ['Atomicity', 'Consistency', 'Isolation', 'Durability'],
    answer: 1,
    explanation: '문제에 제시된 내용은 Atomicity(원자성)에 대한 설명입니다. Consistency(일관성): 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함. Isolation(독립성, 격리성): 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 진행 중에 다른 트랜잭션의 연산이 끼어들 수 없음. Durability(영속성, 지속성): 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함',
  },
  {
    id: 72,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: 'C 언어에서 malloc() 함수에 대한 설명으로 틀린 것은?',
    choices: ['원하는 시점에 원하는 만큼 메모리를 동적으로 할당한다.', '사용자가 입력한 bit만큼 메모리를 할당한다.', 'free 명령어로 할당된 메모리를 해제한다.', '메모리 할당이 불가능할 경우 NULL이 반환된다.'],
    answer: 2,
    explanation: 'malloc() 함수는 입력한 Byte만큼 메모리를 할당하는 함수입니다.',
  },
  {
    id: 73,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '다음 JAVA 코드 출력문의 결과는?\n```java\nSystem.out.println("5 + 2 = " + 3 + 4);\nSystem.out.println("5 + 2 = " + (3 + 4));\n```',
    choices: ['5+2=34, 5+2=34', '5+2+3+4, 5+2=7', '7=7, 7+7', '5+2=34, 5+2=7'],
    answer: 4,
    explanation: '코드 출력문의 결과로 옳은 것은 ④번입니다. Java의 println() 사용시 \'숫자 + 숫자\'는 연산 수행 후의 숫자 결과를, \'문자 + 숫자\'는 문자 숫자 두 값을 이어서 문자 결과를 출력합니다. "5+2=" + 3 + 4에서 "5+2=" + 3은 문자+숫자이므로 5+2=3이라는 문자열. "5+2=3" + 4 또한 문자+숫자이므로 5+2=34라는 결과를 출력합니다. "5+2=" + (3+4)에서 (3+4)은 숫자+숫자이므로 7이 되고, "5+2=" + 7은 문자+숫자이므로 5+2=7이라는 결과를 출력합니다.',
  },
  {
    id: 74,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '다음 C 언어 프로그램의 결과로 옳은 것은?\n```c\n#include <stdio.h>\nmain() {\n    char c = \'A\';\n    c = c + 1;\n    printf("%d", c);\n}\n```',
    choices: ['A', 'B', '65', '66'],
    answer: 4,
    explanation: '문자는 아스키코드로 저장됩니다. 대문자 \'A\'는 아스키코드 값 65이고 1을 더하면 66이 됩니다. 하지만 출력문에서 %d를 사용하므로 정수를 출력하는 %d가 아닌 아스키코드 값 66이 출력되게 됩니다. 결과: 66',
  },
  {
    id: 75,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '오류 제어에 사용되는 자동 반복 요청 방식(ARQ)이 아닌 것은?',
    choices: ['Stop-and-Wait ARQ', 'Go-back-N ARQ', 'Selective-Repeat ARQ', 'Non-Acknowledge ARQ'],
    answer: 4,
    explanation: 'ARQ의 종류 중 Non-Acknowledge라는 ARQ는 없습니다. 자동 반복 요청 방식의 종류에는 Stop-and-Wait(정지-대기) ARQ, Go-Back-N ARQ, Selective-Repeat(선택적 재전송) ARQ, Adaptive(적응적) ARQ가 있습니다.',
  },
  {
    id: 76,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: 'TCP 헤더와 관련한 설명으로 틀린 것은?',
    choices: ['순서 번호(Sequence Number)는 전달하는 바이트마다 번호가 부여된다.', '수신 번호 확인(Acknowledgement Number)은 상대편 호스트에서 받으려는 바이트의 번호를 정의한다.', '체크섬(Checksum)은 데이터를 포함한 세그먼트의 오류를 검사한다.', '윈도우 크기는 송수신 측의 버퍼 크기로 최대 크기는 32767bit이다.'],
    answer: 4,
    explanation: 'TCP 헤더에서 윈도우의 최대 크기는 65,535(2^16-1) Byte입니다.',
  },
  {
    id: 77,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: 'CIDR(Classless Inter-Domain Routing) 표기로 203.241.132.82/27과 같이 사용되었다면, 해당 주소의 서브넷 마스크(Subnet Mask)는?',
    choices: ['255.255.255.0', '255.255.255.224', '255.255.255.240', '255.255.255.248'],
    answer: 2,
    explanation: '문제에 제시된 조건에 맞는 서브넷 마스크는 255.255.255.224입니다. CIDR(Classless Inter-Domain Routing)은 클래스 없는 도메인 간 라우팅 기법으로, CIDR 기법 사용 시 서브넷 마스크는 IP 주소 뒤의 숫자를 이용해 구할 수 있습니다. 203.241.132.82/27 네트워크의 서브넷 마스크는 1의 개수가 27개, 즉 11111111.11111111.11111111.11100000 → 255.255.255.224가 됩니다.',
  },
  {
    id: 78,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: 'TCP/IP에서 사용되는 논리 주소를 물리 주소로 변환시켜주는 프로토콜은?',
    choices: ['TCP', 'ARP', 'FTP', 'IP'],
    answer: 2,
    explanation: 'TCP/IP 네트워크에서 논리 주소를 물리 주소로 변환하는 프로토콜은 ARP(Address Resolution Protocol)입니다. TCP(Transmission Control Protocol): 신뢰성 있는 연결형 서비스를 제공하고, 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공. FTP(File Transfer Protocol): 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜. IP(Internet Protocol): 데이터그램을 기반으로 하는 비연결형 서비스와 패킷의 분해/조립, 주소 지정 경로 선택 기능을 제공',
  },
  {
    id: 79,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '다음 중 가장 약한 결합도(Coupling)는?',
    choices: ['Common Coupling', 'Content Coupling', 'External Coupling', 'Stamp Coupling'],
    answer: 4,
    explanation: '보기 중 가장 약한 결합도는 Stamp Coupling입니다.',
  },
  {
    id: 80,
    subject: 4,
    subjectName: '프로그래밍 언어 활용',
    question: '빈 기억공간의 크기가 20KB, 16KB, 8KB, 40KB 일 때 기억장치 배치 전략으로 "Best Fit"을 사용하여 17KB의 프로그램을 적재할 경우 내부 단편화의 크기는 얼마인가?',
    choices: ['3KB', '23KB', '64KB', '67KB'],
    answer: 1,
    explanation: '최적 적합(Best Fit)은 데이터가 들어갈 수 있는 크기의 빈 영역 중 단편화를 가장 적게 남기는 분할 영역에 배치시키는 방법으로, 17KB보다 큰 기억공간 중 가장 작은 기억공간인 20KB에 배치됩니다. 이때 발생하는 내부 단편화는 3KB(20KB-17KB)입니다.',
  },
  {
    id: 81,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 중 암호화 기법이 아닌 것은?',
    choices: ['AES', 'DES', 'RSA', 'SH'],
    answer: 4,
    explanation: 'SH는 암호화 기법이 아니며 무결성을 검증하기 위해 사용하는 해시 함수입니다.',
  },
  {
    id: 82,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 중 소유 기반 인증(Something You Have)에 속하지 않는 것은?',
    choices: ['지문', '마그네틱 카드', '신분증', 'OTP'],
    answer: 1,
    explanation: '지문은 생체 기반 인증(Something You Are)에 속합니다.',
  },
  {
    id: 83,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 내용이 설명하는 스토리지 시스템은?\n- 하드디스크와 같은 데이터 저장장치를 호스트버스 어댑터에 직접 연결하는 방식\n- 저장장치와 호스트 기기 사이에 네트워크 디바이스 없이 직접 연결하는 방식으로 구성',
    choices: ['DAS', 'NAS', 'SAN', 'NFC'],
    answer: 1,
    explanation: '문제의 지문에서 설명하는 스토리지 시스템은 DAS(Direct Attached Storage)입니다. NAS(Network Attached Storage): 서버와 저장장치를 네트워크를 통해 연결하는 방식. SAN(Storage Area Network): DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로, 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식입니다.',
  },
  {
    id: 84,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '소프트웨어 생명주기 모델 중 나선형 모델(Spiral Model)과 관련한 설명으로 틀린 것은?',
    choices: ['소프트웨어 개발 프로세스를 위험 관리(Risk Management) 측면에서 본 모델이다.', '각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행해야 한다.', '시스템을 여러 부분으로 나누어 여러 번의 개발 주기를 거치면서 시스템을 완성한다.', '요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합한 모델이다.'],
    answer: 2,
    explanation: '②번은 폭포수 모형에 대한 설명입니다.',
  },
  {
    id: 85,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 내용에 적합한 용어는?\n- 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델이다.\n- Google에 의해 고안된 기술로써 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법을 제공한다.\n- 임의의 순서로 정렬된 데이터를 분산 처리하고 이를 다시 합치는 과정을 거친다.',
    choices: ['MapReduce', 'SQL', 'Hijacking', 'Logs'],
    answer: 1,
    explanation: '문제의 지문에 제시된 내용은 MapReduce의 설명입니다. SQL(Structured Query Language): 관계형 데이터베이스에서 데이터를 조작하고 관리하기 위해 사용되는 구조화된 질의 언어. Hijacking: 다른 사람의 세션이나 연결 등을 가로채서 도용하는 행위의 상태를 도용하는 해킹 기법. Logs: 시스템이 시작된 이벤트와 관련된 보안 메시지와 같은 기록하는 것으로, 이러한 로그 분석을 통해 침입 시도의 감지와 추적, 증거 기반을 마련합니다.',
  },
  {
    id: 86,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: 'CMMI의 단계가 아닌 것은?',
    choices: ['초기', '관리', '정의', '반복'],
    answer: 4,
    explanation: '반복은 CMMI의 단계가 아닙니다. CMMI는 초기, 관리, 정의, 정량적 관리, 최적화의 5단계로 구분합니다.',
  },
  {
    id: 87,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: 'LOC 기법에 의하여 예측된 총 라인수가 36000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간을 계산한 결과로 가장 옳은 것은?',
    choices: ['5개월', '10개월', '15개월', '20개월'],
    answer: 4,
    explanation: '프로그래머들의 평균 생산성이 월간 300라인이면 프로그래머 6명의 월간 생산성은 1,800입니다. 총 라인수가 36,000이므로 36,000 / 1,800 = 20, 즉 개발 기간은 20개월입니다.',
  },
  {
    id: 88,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '클라이언트/서버(Client/Server) 모델에서의 소프트웨어 개발에 대한 설명으로 옳지 않은 것은?',
    choices: ['사용자의 요구사항은 서버의 데이터베이스 시스템에 영향을 미친다.', '병목 현상을 없애기 위해 비즈니스 로직을 분리하여 관리할 수 있다.', '미들웨어의 사용은 서버와 클라이언트의 작업량을 증가시켰다.', '대부분 네트워크로 연결되어 있고 인증 작업을 필요로 한다.'],
    answer: 3,
    explanation: '미들웨어(Middleware)는 클라이언트가 서버 측에 어떠한 처리를 요구하고, 또 서버가 그 처리한 결과를 클라이언트에게 돌려주는 과정을 효율적으로 수행하도록 도와주는 소프트웨어입니다. 그러므로 미들웨어의 사용은 서버와 클라이언트간의 작업량을 증가시킬 수 없습니다.',
  },
  {
    id: 89,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '물리적인 사물과 컴퓨터에 동일하게 표현되는 가상의 모델로, 실제 물리적인 자산 대신 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있고, 자산 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있는 모델은?',
    choices: ['최적화', '실행 시간', '디지털 트윈', 'N-Screen'],
    answer: 3,
    explanation: '문제의 내용은 디지털 트윈에 대한 설명입니다. 최적화: 목적에 가장 알맞도록 적절하게 설계하는 것. 실행 시간: 프로세스나 프로그램이 실행되고 종료하기까지의 시간. N-Screen: N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 기술입니다.',
  },
  {
    id: 90,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 설명에서 괄호(ㄱ, ㄴ)에 들어갈 알맞은 암호화 알고리즘은?\n```\n- (ㄱ): 이산 대수 문제를 타원곡선으로 옮겨 기밀성과 효율성을 높인 암호화 알고리즘\n- (ㄴ): 소인수 분해의 어려움에 안전성의 근거를 둔 암호화 알고리즘\n```',
    choices: ['ㄱ: ECC, ㄴ: Rabin', 'ㄱ: DES, ㄴ: Rabin', 'ㄱ: ECC, ㄴ: SHA', 'ㄱ: DES, ㄴ: SHA'],
    answer: 1,
    explanation: '문제의 지문에 제시된 내용 중 ㄱ은 ECC, ㄴ은 Rabin 암호화 알고리즘의 특징입니다.',
  },
{
    id: 91,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '소프트웨어 프로젝트 관리를 효율적으로 수행하기 위한 3P 중 소프트웨어 프로젝트를 수행하기 위한 Task Framework의 고려와 가장 연관되는 것은?',
    choices: ['People', 'Problem', 'Product', 'Process'],
    answer: 4,
    explanation: '문제에 제시된 내용은 프로젝트 관리를 위한 3P 중 Process에 대한 설명입니다. 사람(People): 프로젝트 관리에서 가장 기본이 되는 인적 자원. 문제(Problem): 사용자 입장에서 문제를 분석하여 인식함. 프로세스(Process): 소프트웨어 개발에 필요한 전체적인 작업 계획 및 구조(Framework)입니다.',
  },
  {
    id: 92,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: 'Python 기반의 웹 크롤링(Web Crawling) 프레임워크로 옳은 것은?',
    choices: ['Li-fi', 'Scrapy', 'CrawlCat', 'SBAS'],
    answer: 2,
    explanation: '웹 크롤링을 지원하는 가장 대표적인 프레임워크는 파이썬(Python)의 스크래피(Scrapy)입니다.',
  },
  {
    id: 93,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '악성코드의 유형 중 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로를 증식하는 것은?',
    choices: ['Worm', 'Rogue Ware', 'Adware', 'Reflection Attack'],
    answer: 1,
    explanation: '네트워크를 통해 연속적으로 자신을 복제하는 악성코드는 웜(Worm)입니다. 로그웨어(Rogue Ware): 사용자를 속여 악성코드를 설치하도록 유도하는 소프트웨어. 애드웨어(Adware): 소프트웨어 자체에 광고를 포함하여 이를 보는 대가로 무료로 사용하는 소프트웨어. 반사 공격(Reflection Attack): 송신자가 생성한 메시지를 가로채 접근 권한을 얻는 형태의 공격 기법입니다.',
  },
  {
    id: 94,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 설명에 해당하는 시스템은?\n- 1990년대 David Clock이 처음 제안하였다.\n- 비정상적인 접근의 탐지를 위해 의도적으로 설치해 둔 시스템이다.\n- 침입자를 속여 실제 공격당하는 것처럼 보여줌으로써 크래커를 추적 및 공격기법의 정보를 수집하는 역할을 한다.\n- 쉽게 공격자에게 노출되어야 하며 쉽게 공격이 가능한 것처럼 취약해 보여야 한다.',
    choices: ['Apache', 'Hadoop', 'Honeypot', 'MapReduce'],
    answer: 3,
    explanation: '문제의 지문에 제시된 내용은 허니팟(Honeypot)의 특징입니다. 아파치(Apache): 월드 와이드 웹 컨소시엄(W3C)에서 사용하고 이미지 소프트웨어 재단에서 관리 및 운영하는 서버용 오픈소스 소프트웨어. 하둡(Hadoop): 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼으로, 관계형 데이터베이스(RDB) 건 대용량 데이터를 전송할 때 소요시간(Scoop)이라는 도구를 이용함. 맵리듀스(MapReduce): 대용량 데이터를 분산 처리하기 위한 목적으로 Google에 의해 고안된 프로그래밍 모델입니다.',
  },
  {
    id: 95,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '접근 통제 방법 중 조직 내에서 직무, 직책 등 개인의 역할에 따라 결정하여 부여하는 접근 정책은?',
    choices: ['RBAC', 'DAC', 'MAC', 'QAC'],
    answer: 1,
    explanation: '직무나 직책과 같이 개인의 역할에 따라 접근 권한을 부여하는 접근 정책은 역할 기반 접근통제(RBAC; Role Based Access Control)입니다. 임의 접근통제(DAC; Discretionary Access Control): 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식. 강제 접근통제(MAC; Mandatory Access Control): 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식입니다.',
  },
  {
    id: 96,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 중 프로토타입 모형을 선택하는 것이 가장 적합한 경우는?',
    choices: [
      '구축하고자 하는 시스템의 요구사항이 불분명할 때',
      '고객이 완성된 제품만을 보기 원할 때',
      '고객이 개발 과정에 참여하지 않을 때',
      '소프트웨어 개발 과정에서 발생할 수 있는 위험을 최소화하고자 할 때',
    ],
    answer: 1,
    explanation: '프로토타입 모형은 구축하고자 하는 시스템의 요구사항이 불분명할 때 또는 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본(Prototype)을 만들어 최종 결과물을 예측하는 개발 모형입니다.',
  },
  {
    id: 97,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '빅데이터 분석 기술 중 대량의 데이터를 분석하여 데이터 속에 내재되어 있는 변수 사이의 상호 관계를 규명하여 일정한 패턴을 찾아내는 기법은?',
    choices: ['Data Mining', 'Wm-Bus', 'Digital Twin', 'Zigbee'],
    answer: 1,
    explanation: '대량의 데이터에서 이들의 분석하여 데이터 속에 내재되어 있는 변수 사이의 관계, 규칙을 규명하여 일정한 패턴을 찾아내는 기법을 데이터 마이닝(Data Mining)이라고 합니다. 무선 미터버스(WM-bus): 수도 등의 원격 검침을 위해 사용되는 무선 프로토콜. 디지털 트윈(Digital Twin): 현실속의 사물을 소프트웨어로 가상화한 모델. 지그비(Zigbee): 저속 전송 속도를 갖는 홈오토메이션 및 데이터 네트워크를 위한 표준 기술입니다.',
  },
  {
    id: 98,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 중 블록체인(Blockchain)에 대한 설명으로 틀린 것은?',
    choices: [
      'P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자의 디지털 장비에 분산 저장하는 기술이다.',
      '거래 정보를 중앙 서버에만 저장하여 보안성을 높인다.',
      '분산 원장(Distributed Ledger) 기술이라고도 한다.',
      '비트코인 등 암호화폐에 활용되고 있다.',
    ],
    answer: 2,
    explanation: '블록체인은 중앙 서버가 아닌 P2P 네트워크 참여자 모두에게 분산 저장하는 기술입니다. 중앙 서버에만 저장한다는 것은 틀린 설명입니다.',
  },
  {
    id: 99,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 설명에 해당하는 네트워크 공격 기법은?\n- 허용 범위 이상의 ICMP 패킷을 전송하여 대상 시스템의 네트워크를 마비시킨다.',
    choices: ['Ping of Death', 'Session Hijacking', 'Piggyback Attack', 'XSS'],
    answer: 1,
    explanation: '허용 범위 이상의 ICMP 패킷을 전송하여 대상 시스템의 네트워크를 마비시키는 공격 기법은 죽음의 핑(Ping of Death)입니다.',
  },
  {
    id: 100,
    subject: 5,
    subjectName: '정보시스템 구축 관리',
    question: '다음 중 소프트웨어 재사용에 대한 설명으로 옳지 않은 것은?',
    choices: [
      '소프트웨어 재사용은 이미 개발된 소프트웨어의 전체 또는 일부를 다른 소프트웨어 개발이나 유지에 사용하는 것이다.',
      '소프트웨어 재사용을 통해 개발 시간과 비용을 절감할 수 있다.',
      '소프트웨어 재사용 방법에는 합성 중심과 생성 중심 방법이 있다.',
      '소프트웨어 재사용은 새로운 개발 방법론을 사용해야만 가능하다.',
    ],
    answer: 4,
    explanation: '소프트웨어 재사용은 특정 개발 방법론에 국한되지 않으며, 다양한 방법론에서 활용할 수 있습니다.',
  }
]

export default questions
