# 2026년 1회 정보처리기사 필기시험(복원) — 1~20번 문제

---

**1번.** 정형 기술 검토(FTR)의 지침 사항으로 가장 옳지 않은 것은?
1. 제품의 검토에만 집중한다.
2. 문제 영역을 명확히 표현한다.
3. 참가자의 수를 제한하고 사전 준비를 강요한다.
4. **논쟁이나 반박을 제한하지 않는다.** ✅ 정답 / 입력한 답

> 💡 **해설:** 정형 기술 검토(FTR, Formal Technical Review)는 소프트웨어 결함을 조기에 발견하기 위한 검토 방법이다. FTR의 주요 지침 사항은 ① 제품의 검토에만 집중(생산자를 비판하지 않음), ② 문제 영역의 명확한 표현, ③ 참가자 수 제한 및 사전 준비 철저, ④ **논쟁과 반박은 제한**한다(의제에 벗어나는 논쟁 금지)는 것이다. 따라서 "논쟁이나 반박을 제한하지 않는다"는 FTR 지침에 옳지 않은 설명이다.

---

**2번.** 유스케이스 다이어그램의 구성요소가 아닌 것은?
1. 유스케이스(Usecase)
2. 액터(Actor)
3. 시스템(System)
4. **클래스(Class)** ✅ 정답 / 입력한 답

> 💡 **해설:** 유스케이스 다이어그램(Use Case Diagram)의 구성요소는 유스케이스(Usecase), 액터(Actor), 시스템(System), 그리고 이들 간의 관계(연관, 포함, 확장, 일반화)이다. 클래스(Class)는 클래스 다이어그램의 구성요소이며 유스케이스 다이어그램에는 포함되지 않는다.

---

**3번.** User Interface 설계 시 오류 메시지나 경고에 관한 지침으로 가장 거리가 먼 것은?
1. 메시지는 이해하기 쉬워야 한다.
2. 오류로부터 회복을 위한 구체적인 설명이 제공되어야 한다.
3. 오류로 인해 발생할 수 있는 부정적인 내용을 적극적으로 사용자들에게 알려야 한다.
4. **소리나 색의 사용을 줄이고 텍스트로만 전달하도록 한다.** ✅ 정답 / 입력한 답

> 💡 **해설:** UI 오류 메시지 설계 지침에서 오류 메시지는 이해하기 쉬워야 하고, 회복 방법을 구체적으로 안내해야 하며, 부정적 결과도 사용자에게 알려야 한다. 그러나 "소리나 색의 사용을 줄이고 텍스트로만 전달"하는 것은 잘못된 지침이다. 오히려 소리, 색상, 아이콘 등 다양한 시각·청각적 수단을 활용하여 오류를 효과적으로 전달해야 한다. 텍스트만 사용하면 오히려 사용자가 오류를 인지하기 어려울 수 있다.

---

**4번.** 파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은?
1. 노드와 간선으로 구성된다.
2. **서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복한다.** ✅ 정답 / 입력한 답
3. 계층 모델이라고도 한다.
4. 3개의 서브 시스템(모델, 뷰, 제어)으로 구성되어 있다.

> 💡 **해설:** 파이프-필터(Pipe-Filter) 아키텍처는 데이터 스트림을 처리하는 시스템에 적합한 구조로, 각 필터(서브 시스템)가 입력 데이터를 받아 처리한 뒤 결과를 파이프를 통해 다음 필터로 전달하는 방식을 반복한다. 오답 분석: ①번(노드와 간선)은 저장소(Repository) 아키텍처나 그래프 구조, ③번(계층 모델)은 레이어드(Layered) 아키텍처, ④번(모델-뷰-제어)은 MVC 아키텍처에 대한 설명이다.

---

**5번.** CASE가 갖고 있는 주요 기능이 아닌 것은? ❌ 오답
1. 그래픽 지원 ← 입력한 답
2. 소프트웨어 생명주기 전 단계의 연결
3. **언어 번역** ✅ 정답
4. 다양한 소프트웨어 개발 모형 지원

> 💡 **해설:** CASE(Computer-Aided Software Engineering)는 소프트웨어 개발 전 과정을 자동화 도구로 지원하는 기술이다. CASE의 주요 기능에는 ① 그래픽을 통한 소프트웨어 구조 표현, ② 소프트웨어 생명주기 전 단계 연결, ③ 다양한 소프트웨어 개발 모형 지원, ④ 문서화 지원 등이 있다. "언어 번역"은 컴파일러나 인터프리터의 기능으로 CASE의 주요 기능에 해당하지 않는다. (수험자 오답: 1번 그래픽 지원을 선택했으나 그래픽 지원은 CASE의 주요 기능임)

---

**6번.** 다음에서 설명하는 응집도의 유형은 무엇인가? (동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우의 응집도)
1. 논리적 응집도
2. 절차적 응집도
3. 시간적 응집도
4. **교환적 응집도** ✅ 정답 / 입력한 답

> 💡 **해설:** 응집도(Cohesion)의 유형은 강한 것부터 약한 순서로 기능적 > 순차적 > 교환적(통신적) > 절차적 > 시간적 > 논리적 > 우연적 순이다. 교환적(통신적) 응집도(Communicational Cohesion)는 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모인 경우로, 데이터를 공유한다는 특징이 있다. 오답 분석: ①논리적 응집도는 유사한 성격의 기능들이 모인 경우, ②절차적 응집도는 순서대로 절차를 따르는 경우, ③시간적 응집도는 같은 시간대에 실행되는 기능들이 모인 경우이다.

---

**7번.** 모듈 내부 요소 간의 관련성을 무엇이라고 하는가?
1. **cohesion** ✅ 정답 / 입력한 답
2. coupling
3. method
4. chaining

> 💡 **해설:** 모듈 설계의 핵심 개념 두 가지는 응집도(Cohesion)와 결합도(Coupling)이다. 응집도(Cohesion)는 모듈 내부 요소들 간의 관련성(기능적 연관성)을 나타내며, 높을수록 좋다. 반면 결합도(Coupling)는 모듈 간 상호 의존성(외부 모듈과의 연관성)을 나타내며, 낮을수록 좋다. 따라서 "모듈 내부 요소 간의 관련성"은 cohesion(응집도)이다.

---

**8번.** 애자일(Agile) 프로세스 모델에 대한 설명으로 틀린 것은?
1. **변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.** ✅ 정답 / 입력한 답
2. 프로세스와 도구 중심이 아닌 개개인과의 상호 소통을 통해 의견을 수렴한다.
3. 협상과 계약보다는 고객과의 협력을 중시한다.
4. 문서 중심이 아닌, 실행 가능한 소프트웨어를 중시한다.

> 💡 **해설:** 애자일 선언(Agile Manifesto)의 핵심 가치는 ① 프로세스·도구보다 개인과 상호작용, ② 포괄적 문서보다 작동하는 소프트웨어, ③ 계약 협상보다 고객과의 협력, ④ **계획을 따르기보다 변화에 대응**하는 것이다. 따라서 "변화에 대한 대응보다는 자세한 계획을 중심으로 개발한다"는 애자일의 반대 개념인 전통적 개발 방법론(폭포수 모델 등)에 해당하여 틀린 설명이다.

---

**9번.** 다음 중 객체에게 어떤 행위를 하도록 지시하는 방법은 무엇인가?
1. Object
2. Method
3. **Message** ✅ 정답 / 입력한 답
4. Instance

> 💡 **해설:** 객체지향의 주요 개념 중 메시지(Message)는 객체 간의 통신 수단으로, 한 객체가 다른 객체에게 특정 행위(메서드 실행)를 요청하는 방법이다. 오답 분석: Object(객체)는 데이터와 행위를 묶은 단위, Method(메서드)는 객체가 수행할 수 있는 동작(함수), Instance(인스턴스)는 클래스로부터 생성된 실제 객체이다. 행위를 "지시"하는 것은 메시지 전송이다.

---

**10번.** 다음에서 설명하는 디자인 패턴의 유형은? (각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고, 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴)
1. **Visitor** ✅ 정답 / 입력한 답
2. State
3. Command
4. Strategy

> 💡 **해설:** Visitor(방문자) 패턴은 GoF 행위(Behavioral) 패턴 중 하나로, 데이터 구조와 처리 기능을 분리하는 패턴이다. Visitor 클래스가 각 Element(요소) 클래스를 "방문(visit)"하며 특정 작업을 수행한다. 이를 통해 기존 클래스를 수정하지 않고도 새로운 기능을 추가할 수 있다. 오답 분석: State는 객체 상태에 따라 행위를 변경, Command는 요청을 객체로 캡슐화, Strategy는 알고리즘을 캡슐화하여 교환 가능하게 하는 패턴이다.

---

**11번.** 애자일(Agile) 기법 중 스크럼(Scrum)과 관련된 용어에 대한 설명이 틀린 것은?
1. 스크럼 마스터(Scrum Master)는 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡는다.
2. 제품 백로그(Product Backlog)는 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함될 수 있다.
3. **스프린트(Sprint)는 하나의 완성된 최종 결과물을 만들기 위한 주기로 3달 이상의 장기간으로 결정된다.** ✅ 정답 / 입력한 답
4. 속도(Velocity)는 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있다.

> 💡 **해설:** 스크럼(Scrum)의 스프린트(Sprint)는 실제 개발을 수행하는 짧은 반복 주기로, 일반적으로 **1~4주(최대 30일)** 이내의 단기간으로 설정한다. "3달 이상의 장기간"이라는 설명은 완전히 틀린 설명이다. 스프린트가 짧을수록 빠른 피드백과 변화 대응이 가능하다. 나머지 선택지는 모두 올바른 스크럼 용어 설명이다.

---

**12번.** 다음 중 애자일 기법이 아닌 것은? ❌ 오답
1. xp
2. crystal ← 입력한 답
3. scrum
4. **spice** ✅ 정답

> 💡 **해설:** 대표적인 애자일 방법론으로는 XP(eXtreme Programming), Crystal, Scrum, DSDM(Dynamic Systems Development Method), FDD(Feature Driven Development), Kanban 등이 있다. SPICE(Software Process Improvement and Capability dEtermination)는 ISO/IEC 15504 기반의 소프트웨어 **프로세스 평가 및 개선 표준**으로 애자일 기법이 아니다. Crystal은 팀 규모와 시스템 중요도에 따라 다양한 변형이 있는 애자일 방법론이다. (수험자 오답: Crystal을 선택했으나 Crystal은 애자일 기법에 해당함)

---

**13번.** 다음에서 설명하는 사용자 인터페이스의 설계 원칙은? (정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작)
1. 직관성(Intuitiveness)
2. **유효성(Effectiveness)** ✅ 정답 / 입력한 답
3. 학습성(Learnability)
4. 유연성(Flexibility)

> 💡 **해설:** UI 설계의 4대 원칙은 ① 직관성(Intuitiveness): 누구나 쉽게 이해하고 사용, ② **유효성(Effectiveness): 정확하고 완벽하게 사용자의 목표 달성**, ③ 학습성(Learnability): 초보자도 쉽게 배울 수 있음, ④ 유연성(Flexibility): 다양한 요구와 상황에 적응 가능. "정확하고 완벽하게 사용자의 목표가 달성"은 유효성(Effectiveness)에 해당한다.

---

**14번.** UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 한다는 것은?
1. 유효성
2. **직관성** ✅ 정답 / 입력한 답
3. 무결성
4. 유연성

> 💡 **해설:** UI 설계 4대 원칙 중 직관성(Intuitiveness)은 "누구나 쉽게 이해하고 사용할 수 있어야 한다"는 원칙이다. 별도의 학습 없이도 UI를 보는 것만으로 사용 방법을 파악할 수 있어야 한다. 참고로 무결성은 UI 설계 원칙에 포함되지 않는 개념이다. 13번과 연계하여 유효성(정확한 목표 달성)과 직관성(쉬운 이해와 사용)을 구분해서 암기해야 한다.

---

**15번.** 다음에서 설명하고 있는 디자인 패턴은 무엇인가? (상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 패턴)
1. Template Method
2. Observer
3. State
4. **Factory Method** ✅ 정답 / 입력한 답

> 💡 **해설:** Factory Method 패턴은 GoF 생성(Creational) 패턴 중 하나로, 객체 생성을 위한 인터페이스를 상위 클래스(추상 클래스)에서 정의하되, 실제 어떤 클래스의 인스턴스를 생성할지는 하위 클래스에서 결정하도록 위임하는 패턴이다. 오답 분석: Template Method는 행위 패턴으로 알고리즘 골격을 상위 클래스에 정의하고 세부 구현을 하위 클래스에 위임, Observer는 상태 변화 시 의존 객체들에게 알림, State는 객체 내부 상태 변화에 따라 행위를 변경하는 패턴이다.

---

**16번.** 객체지향 기법에서 같은 클래스에 속한 각각의 객체를 의미하는 것은?
1. **instance** ✅ 정답 / 입력한 답
2. message
3. method
4. module

> 💡 **해설:** 인스턴스(Instance)는 클래스(Class)를 통해 실제 메모리에 생성된 구체적인 객체를 말한다. 즉 같은 클래스에 속한 각각의 객체가 인스턴스이다. 예를 들어 '자동차'라는 클래스에서 '소나타', '아반떼' 등 구체적인 객체가 인스턴스이다. 오답 분석: message는 객체 간 행위 요청 수단, method는 객체의 동작(함수), module은 독립적 기능 단위이다.

---

**17번.** 소프트웨어 설계 시 구축된 플랫폼의 성능 특성 분석에 사용되는 측정 항목이 아닌 것은?
1. **서버 튜닝(Server Tuning)** ✅ 정답 / 입력한 답
2. 가용성(Availability)
3. 사용률(Utilization)
4. 응답시간(Response Time)

> 💡 **해설:** 플랫폼 성능 특성 분석의 주요 측정 항목으로는 가용성(Availability), 응답시간(Response Time), 사용률(Utilization), 처리량(Throughput), 신뢰성(Reliability) 등이 있다. 서버 튜닝(Server Tuning)은 성능을 **측정**하는 항목이 아니라 성능을 **개선·최적화**하는 활동에 해당하므로 측정 항목이 아니다.

---

**18번.** 아키텍처 설계 과정으로 올바른 순서로 나열된 것은?
1. **ㄱ 설계 목표 설정 → ㄴ 시스템 타입 결정 → ㄷ 스타일 적용 및 커스터마이즈 → ㄹ 서브 시스템의 기능/인터페이스 동작 작성 → ㅁ 아키텍처 설계 검토** ✅ 정답 / 입력한 답
2. ㅁ ㄱ ㄴ ㄹ ㄷ
3. ㄱ ㅁ ㄴ ㄹ ㄷ
4. ㄱ ㄴ ㄷ ㅁ ㄹ

> 💡 **해설:** 소프트웨어 아키텍처 설계 과정의 올바른 순서는 다음과 같다: ① 설계 목표 설정(시스템의 목적과 요구사항 파악) → ② 시스템 타입 결정(적합한 시스템 유형 선택) → ③ 아키텍처 스타일 적용 및 커스터마이즈(파이프-필터, MVC, 레이어드 등 선택 및 적용) → ④ 서브 시스템의 기능/인터페이스 동작 작성(세부 설계) → ⑤ 아키텍처 설계 검토(설계 결과 검증). 검토는 항상 마지막 단계에서 수행된다.

---

**19번.** XP(eXtreme Programming)의 5가지 가치로 거리가 먼 것은?
1. 용기
2. 의사소통
3. **정형 분석** ✅ 정답 / 입력한 답
4. 피드백

> 💡 **해설:** XP(eXtreme Programming)의 5가지 핵심 가치는 ① 의사소통(Communication), ② 단순성(Simplicity), ③ 피드백(Feedback), ④ 용기(Courage), ⑤ 존중(Respect)이다. "정형 분석"은 XP의 가치에 포함되지 않는다. 정형 분석(Formal Analysis)은 수학적 기법을 사용하는 소프트웨어 검증 방법으로 XP와는 다른 개념이다.

---

**20번.** 객체 지향 설계 원칙에 해당하지 않는 것은?
1. 단일 책임의 원칙(Single Responsibility Principle)
2. 리스코프 치환의 원칙(Liskov Substitution Principle)
3. **인터페이스 통합의 원칙(Interface Integration Principle)** ✅ 정답 / 입력한 답
4. 개방 폐쇄 원칙(Open Close Principle)

> 💡 **해설:** 객체지향 설계 원칙인 SOLID는 ① S - 단일 책임 원칙(SRP), ② O - 개방-폐쇄 원칙(OCP), ③ L - 리스코프 치환 원칙(LSP), ④ I - **인터페이스 분리 원칙(ISP, Interface Segregation Principle)**, ⑤ D - 의존 역전 원칙(DIP)으로 구성된다. "인터페이스 통합의 원칙(Interface Integration Principle)"은 존재하지 않는 원칙이다. 실제 SOLID의 I는 인터페이스 **분리** 원칙(클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 함)이다.

---

## 오답 요약

| 문제 | 입력한 답 | 정답 |
|------|-----------|------|
| 5번 | 1. 그래픽 지원 | 3. 언어 번역 |
| 12번 | 2. crystal | 4. spice |

---


21번. 소프트웨어 재공학의 주요 활동 중 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업을 의미하는 것은?

Analysis
Migration ✅ 정답/입력한 답
Restructuring
Reverse Engineering

> 💡 **해설:** 소프트웨어 재공학의 주요 활동은 다음과 같다.
> - **Analysis(분석):** 기존 소프트웨어의 명세서를 확인하고 재공학 대상을 선정하는 단계
> - **Migration(이식):** 기존 소프트웨어를 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업
> - **Restructuring(재구조화):** 기존 소프트웨어를 다시 설계하거나 코드를 재작성하는 작업
> - **Reverse Engineering(역공학):** 기존 소프트웨어를 분석하여 소프트웨어 개발 초기 단계 결과물을 도출하는 작업
>
> 정답은 **Migration**이다.


22번. 알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?

단위 테스트
인수 테스트 ✅ 정답
통합 테스트 ← 입력한 답 (O 표시 → 정답과 동일 처리됨)
시스템 테스트


※ 22번은 답안 목록에서 O로 표시됨. 텍스트 배치 상 2번이 정답, 입력한 답도 정답으로 처리된 것으로 보임.

> 💡 **해설:** **알파(Alpha) 테스트**와 **베타(Beta) 테스트**는 모두 **인수 테스트(Acceptance Test)**의 유형이다.
> - **알파 테스트:** 개발자 환경에서 통제된 상태로 사용자가 수행하는 테스트
> - **베타 테스트:** 실제 사용자 환경에서 불특정 다수의 사용자가 수행하는 테스트
>
> 인수 테스트는 시스템이 사용자 요구 사항을 충족하는지 검증하는 최종 단계 테스트이며, 알파/베타 테스트는 그 대표적인 형태이다. 정답은 **인수 테스트**이다.


23번. 비선형 자료 구조에 해당하는 것은?

큐(Queue)
그래프(Graph) ✅ 정답/입력한 답
데크(Deque)
스택(Stack)

> 💡 **해설:** 자료 구조는 선형과 비선형으로 구분된다.
> - **선형 자료 구조:** 데이터가 일렬로 연결된 구조 → 배열, 연결 리스트, 스택(Stack), 큐(Queue), 데크(Deque)
> - **비선형 자료 구조:** 데이터가 계층적 또는 망 형태로 연결된 구조 → **트리(Tree), 그래프(Graph)**
>
> 큐, 데크, 스택은 선형 자료 구조이므로 비선형에 해당하는 것은 **그래프(Graph)**이다.


24번. 스택(Stack)에 대한 옳은 내용으로만 나열된 것은?

㉠ FIFO 방식으로 처리된다.
㉡ 순서 리스트의 뒤(Rear)에서 노드가 삽입되며, 앞(Front)에서 노드가 제거된다.
㉢ 선형 리스트의 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료 구조이다.
㉣ 인터럽트 처리, 서브루틴 호출 작업 등에 응용된다.


㉠, ㉡
㉡, ㉢
㉣ ✅ 정답/입력한 답
㉠, ㉡, ㉢, ㉣

> 💡 **해설:** 각 항목의 옳고 그름을 분석하면 다음과 같다.
> - **㉠ 틀림:** 스택은 **LIFO(Last In First Out)** 방식이다. FIFO는 큐(Queue)의 특성이다.
> - **㉡ 틀림:** Rear에서 삽입, Front에서 제거하는 것은 **큐(Queue)**의 특성이다. 스택은 한쪽 끝(Top)에서만 삽입·삭제가 이루어진다.
> - **㉢ 틀림:** 양쪽 끝에서 삽입과 삭제가 모두 가능한 것은 **데크(Deque)**의 특성이다.
> - **㉣ 맞음:** 스택은 인터럽트 처리, 서브루틴 호출, 수식 계산(후위 표기법), 되돌아가기(undo) 등에 활용된다.
>
> 따라서 옳은 내용은 **㉣**만 해당된다.


25번. 순서가 A, B, C, D로 정해진 입력자료를 Push, Push, Pop, Push, Push, Pop, Pop, Pop 순서로 스택 연산을 수행하는 경우 출력 결과는?

B D C A ✅ 정답/입력한 답
A B C D
B A C D
A B D C

> 💡 **해설:** 스택 연산을 순서대로 추적하면 다음과 같다.
>
> | 연산 | 동작 | 스택 상태 | 출력 |
> |------|------|-----------|------|
> | Push | A 삽입 | [A] | - |
> | Push | B 삽입 | [A, B] | - |
> | Pop | B 제거 | [A] | **B** |
> | Push | C 삽입 | [A, C] | - |
> | Push | D 삽입 | [A, C, D] | - |
> | Pop | D 제거 | [A, C] | **D** |
> | Pop | C 제거 | [A] | **C** |
> | Pop | A 제거 | [] | **A** |
>
> 출력 결과: **B D C A**


26번. 소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?

Brooks의 법칙
Boehm의 법칙
Pareto의 법칙 ✅ 정답/입력한 답
Jackson의 법칙

> 💡 **해설:** **파레토(Pareto)의 법칙**은 이탈리아 경제학자 빌프레도 파레토가 제안한 "80대 20 법칙"으로, 소프트웨어 테스트에서는 "오류의 80%가 전체 모듈의 20%에서 발견된다"는 원리로 적용된다. 이는 테스트 자원을 집중해야 할 영역을 선정하는 데 활용된다.
> - Brooks의 법칙: 지연된 프로젝트에 인력을 추가하면 오히려 더 지연된다.
> - Boehm의 법칙: 개발 초기에 결함을 발견할수록 수정 비용이 낮다.


27번. 블랙박스 테스트 기법으로 거리가 먼 것은?

기초 경로 검사 ✅ 정답/입력한 답
동치 클래스 분해
경곗값 분석
원인 결과 그래프

> 💡 **해설:** **블랙박스 테스트(Black Box Test)**는 소프트웨어의 내부 구조를 보지 않고 기능 중심으로 테스트하는 기법이다.
> - 블랙박스 기법: 동치 클래스 분해(동치 분할), 경곗값 분석, 원인 결과 그래프(cause-effect graphing), 오류 예측, 비교 검사 등
>
> **기초 경로 검사(Basic Path Testing)**는 제어 흐름 그래프를 이용해 프로그램 내부 논리 구조를 분석하는 **화이트박스(White Box) 테스트** 기법이다. 따라서 블랙박스 기법과 거리가 가장 멀다.


28번. 정렬된 n개의 데이터를 처리하는데 O(nlog₂n)의 시간이 소요되는 정렬 알고리즘은?

선택 정렬
삽입 정렬
버블 정렬
합병 정렬 ✅ 정답/입력한 답

> 💡 **해설:** 각 정렬 알고리즘의 시간 복잡도를 비교하면 다음과 같다.
>
> | 정렬 | 최선 | 평균 | 최악 |
> |------|------|------|------|
> | 선택 정렬 | O(n²) | O(n²) | O(n²) |
> | 삽입 정렬 | O(n) | O(n²) | O(n²) |
> | 버블 정렬 | O(n²) | O(n²) | O(n²) |
> | **합병 정렬** | **O(nlog₂n)** | **O(nlog₂n)** | **O(nlog₂n)** |
> | 퀵 정렬 | O(nlog₂n) | O(nlog₂n) | O(n²) |
>
> **합병 정렬(Merge Sort)**은 분할 정복 기법을 사용하며, 항상 O(nlog₂n)의 시간 복잡도를 보장한다. 정답은 **합병 정렬**이다.


29번. 인터페이스 구현 검증 도구가 아닌 것은?

Foxbase ✅ 정답/입력한 답
STAF
watir
xUnit

> 💡 **해설:** 인터페이스 구현 검증 도구에는 xUnit, STAF, FitNesse, NTAF, Selenium, Watir, Robot Framework 등이 있다.
> - **xUnit:** 다양한 언어를 지원하는 단위 테스트 프레임워크
> - **STAF:** 서비스 호출 및 컴포넌트 재사용 기반의 테스트 자동화 프레임워크
> - **Watir:** Ruby 기반의 웹 애플리케이션 테스트 자동화 도구
>
> **Foxbase**는 dBASE 호환 데이터베이스 관리 시스템(DBMS)으로, 인터페이스 구현 검증과 무관하다. 정답은 **Foxbase**이다.


30번. 다음 자료를 버블 정렬로 오름차순 정렬 시 PASS 2의 수행 결과는? (9, 6, 7, 3, 5)

3, 5, 6, 7, 9
6, 7, 3, 5, 9
3, 5, 9, 6, 7
6, 3, 5, 7, 9 ✅ 정답/입력한 답

> 💡 **해설:** 버블 정렬은 인접한 두 원소를 비교하여 큰 값을 뒤로 보내는 방식이다.
>
> 초기 상태: **9, 6, 7, 3, 5**
>
> **PASS 1** (가장 큰 값 9를 맨 뒤로):
> - 9↔6 → 6, 9, 7, 3, 5
> - 9↔7 → 6, 7, 9, 3, 5
> - 9↔3 → 6, 7, 3, 9, 5
> - 9↔5 → **6, 7, 3, 5, 9**
>
> **PASS 2** (두 번째로 큰 값 7을 뒤에서 두 번째로):
> - 6↔7 → 6, 7, 3, 5, 9 (변화 없음)
> - 7↔3 → 6, 3, 7, 5, 9
> - 7↔5 → **6, 3, 5, 7, 9**
>
> PASS 2 결과: **6, 3, 5, 7, 9**


31번. S/W Project 말기에 새로운 인원을 추가 투입하면 더욱 지연된다는 법칙은?

Putnam의 법칙
Mayer의 법칙
Brooks의 법칙 ✅ 정답/입력한 답
Boehm의 법칙

> 💡 **해설:** **Brooks의 법칙(Brook's Law)**은 프레더릭 브룩스가 저서 "맨먼스 미신(The Mythical Man-Month)"에서 제안한 법칙으로, "지연된 소프트웨어 프로젝트에 인력을 추가 투입하면 오히려 더 늦어진다"는 내용이다. 신규 인원의 교육 비용, 기존 인원과의 의사소통 오버헤드 증가 등이 주요 원인이다. 정답은 **Brooks의 법칙**이다.


32번. 결함 관리 프로세스 단계 설명으로 가장 적절하지 않은 것은?

결함 등록(Registration): 발견된 오류를 시스템에 기록하고 보고하는 단계
결함 검토(Review): 실제 오류인지, 중복 여부 분석하는 단계
결함 할당(Assignment): 검토된 결함 해결을 위해 담당자를 지정하는 단계
결함 수정(Correction): 할당된 결함 조치가 완료되어 '수정 완료' 상태가 된 것을 의미한다. ✅ 정답/입력한 답

> 💡 **해설:** 결함 관리 프로세스의 단계는 일반적으로 다음과 같다:
> 결함 등록 → 결함 검토 → 결함 할당 → **결함 수정** → 결함 재확인 → 결함 종료
>
> - 결함 수정(Correction) 단계는 담당자가 결함을 실제로 **수정하는 작업을 수행하는 단계**이지, 이미 완료된 상태를 의미하지 않는다.
> - "할당된 결함 조치가 완료되어 '수정 완료' 상태가 된 것"이라는 설명은 **결함 재확인(Re-test)** 또는 결함 종료 단계에 더 가깝다.
>
> 따라서 결함 수정에 대한 설명이 가장 적절하지 않다.


33번. 다음에서 설명하는 테스트의 종류는? (입력 조건에 타당/비타당 자료를 나누어 결과 확인)

equivalence partitioning test ✅ 정답/입력한 답
boundary value analysis
comparision testing
cause-effect graphing testing

> 💡 **해설:** **동치 분할 테스트(Equivalence Partitioning Test)**는 입력 데이터를 유사한 특성을 가진 그룹(동치 클래스)으로 분류하여 각 그룹에서 대표 값을 선택해 테스트하는 기법이다.
> - 유효 동치 클래스(Valid Equivalence Class): 타당한 입력값의 집합
> - 무효 동치 클래스(Invalid Equivalence Class): 비타당한 입력값의 집합
>
> 입력 조건에 대해 타당한 자료와 비타당한 자료를 나누어 테스트 케이스를 작성하는 기법이므로 정답은 **equivalence partitioning test**이다.


34번. 버전 관리 항목 중 저장소에 새로운 버전의 파일로 갱신하는 것을 의미하는 용어는?

형상 검사(Configuration Audit)
롤백(Rollback)
단위 테스트(Unit Test)
체크인(Check-In) ✅ 정답/입력한 답

> 💡 **해설:** 버전 관리 관련 주요 용어는 다음과 같다.
> - **체크인(Check-In):** 로컬에서 수정한 파일을 저장소(Repository)에 새로운 버전으로 갱신(업로드)하는 작업
> - **체크아웃(Check-Out):** 저장소에서 파일을 로컬로 가져오는 작업
> - **롤백(Rollback):** 소프트웨어를 이전 버전으로 되돌리는 작업
> - **형상 검사(Configuration Audit):** 형상 항목의 무결성을 검증하는 활동
>
> 정답은 **체크인(Check-In)**이다.


35번. 단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은?

알고리즘 오류에 따른 원치 않는 결과
탈출구가 없는 반복문의 사용
모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과 ✅ 정답/입력한 답
틀린 계산 수식에 의한 잘못된 결과

> 💡 **해설:** **단위 테스트(Unit Test)**는 개별 모듈(함수, 메서드)을 독립적으로 테스트하는 단계이다.
> 단위 테스트에서 발견 가능한 오류:
> - 알고리즘 오류
> - 무한 루프(탈출구 없는 반복문)
> - 잘못된 계산 수식
> - 데이터 타입 오류
> - 경계값 오류 등
>
> **모듈 간의 비정상적 상호작용**은 개별 모듈이 아닌 모듈들이 연결된 상태에서 발생하는 문제이므로, **통합 테스트(Integration Test)**에서 발견되는 오류에 해당한다.


36번. 선형 자료 구조에 해당하는 것은?

스택, 큐, 트리
큐, 데크, 스택 ✅ 정답/입력한 답
큐, 그래프
그래프, 리스트

> 💡 **해설:** 자료 구조의 분류:
> - **선형 자료 구조:** 배열(Array), 연결 리스트(Linked List), **스택(Stack), 큐(Queue), 데크(Deque)**
> - **비선형 자료 구조:** 트리(Tree), 그래프(Graph)
>
> 트리와 그래프는 비선형 자료 구조이므로, 선형 자료 구조만으로 구성된 것은 **큐, 데크, 스택**이다.


37번. 분할 정복에 기반한 알고리즘, 피벗을 사용하며 최악의 경우 N(N-1)/2회의 비교를 수행해야 하는 정렬은?

Selection Sort
Bubble Sort
Insert Sort
Quick Sort ✅ 정답/입력한 답

> 💡 **해설:** **퀵 정렬(Quick Sort)**의 특징:
> - **분할 정복(Divide and Conquer)** 기법을 사용
> - **피벗(Pivot)**을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분리
> - 평균 시간 복잡도: **O(nlog₂n)**
> - 최악의 경우(이미 정렬된 경우): **O(n²)** → N(N-1)/2회의 비교
> - 최악의 경우는 피벗이 항상 최솟값 또는 최댓값이 될 때 발생
>
> 정답은 **Quick Sort**이다.


38번. 단위 테스트에서 하위 모듈을 호출하고 파라미터를 전달하는 가상의 모듈로 상향식 테스트에 필요한 것은?

테스트 스텁(Test Stub)
테스트 드라이버(Test Driver) ✅ 정답/입력한 답
테스트 슈트(Test Suites)
테스트 케이스(Test Case)

> 💡 **해설:** 통합 테스트에서 사용하는 가상 모듈의 종류:
> - **테스트 드라이버(Test Driver):** 테스트 대상 모듈을 호출하고 파라미터를 전달하며 결과를 확인하는 상위 가상 모듈. **상향식(Bottom-Up) 통합 테스트**에서 사용
> - **테스트 스텁(Test Stub):** 테스트 대상 모듈이 호출하는 하위 가상 모듈. **하향식(Top-Down) 통합 테스트**에서 사용
>
> 문제에서 "하위 모듈을 호출하고 파라미터를 전달하는 가상의 모듈"이며 "상향식 테스트에 필요한 것"이라고 했으므로 정답은 **테스트 드라이버(Test Driver)**이다.


39번. 디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?

콘텐츠 암호화 및 키 관리
콘텐츠 식별체계 표현
콘텐츠 오류 감지 및 복구 ✅ 정답/입력한 답
라이선스 발급 및 관리

> 💡 **해설:** **디지털 저작권 관리(DRM, Digital Rights Management)**는 디지털 콘텐츠의 저작권 보호를 위한 기술로, 주요 구성 요소는 다음과 같다.
> - 콘텐츠 암호화 및 키 관리
> - 콘텐츠 식별체계 표현(메타데이터, DOI 등)
> - 라이선스 발급 및 관리
> - 패키저(Packager), 클리어링 하우스(Clearing House) 등
>
> **콘텐츠 오류 감지 및 복구**는 DRM의 기능이 아니라 데이터 무결성이나 오류 제어(RAID, 패리티 등)와 관련된 기술이다. 정답은 **콘텐츠 오류 감지 및 복구**이다.


40번. 다음이 설명하는 테스트 용어는? (사전에 정의된 참값을 입력하여 비교하는 기법, 참/샘플링/휴리스틱/일관성 검사 포함) ❌ 오답

테스트 케이스 ← 입력한 답
테스트 시나리오
테스트 오라클 ✅ 정답
테스트 데이터

> 💡 **해설:** **테스트 오라클(Test Oracle)**은 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값(예상 결과)과 실제 결과를 비교하는 메커니즘이다.
>
> 테스트 오라클의 유형:
> - **참(True) 오라클:** 모든 입력값에 대해 기대 결과를 확인
> - **샘플링(Sampling) 오라클:** 일부 입력값에 대해서만 기대 결과 확인
> - **휴리스틱(Heuristic) 오라클:** 경험적 원리로 기대 결과 확인
> - **일관성(Consistent) 검사 오라클:** 이전 실행 결과와 비교하여 일관성 확인
>
> 입력한 답인 **테스트 케이스**는 입력값, 실행 조건, 기대 결과를 정의한 문서로 오라클과는 다른 개념이다. 정답은 **테스트 오라클**이다.


41번. SQL 명령 중 그 성격이 나머지 셋과 다른 하나는?

CREATE ✅ 정답/입력한 답
SELECT
INSERT
UPDATE

> 💡 **해설:** SQL 명령어는 역할에 따라 분류된다.
> - **DDL(Data Definition Language):** CREATE, ALTER, DROP, TRUNCATE → 데이터베이스 구조(스키마) 정의
> - **DML(Data Manipulation Language):** SELECT, INSERT, UPDATE, DELETE → 데이터 조작
> - **DCL(Data Control Language):** GRANT, REVOKE → 권한 제어
>
> SELECT, INSERT, UPDATE는 모두 DML에 속하지만, **CREATE는 DDL**에 속하므로 성격이 다른 하나이다. 정답은 **CREATE**이다.


42번. 뷰(View)에 대한 옳은 내용으로만 나열한 것은?

ⓐ 뷰는 저장장치 내에 물리적으로 존재한다.
ⓑ 뷰가 정의된 기본 테이블이 삭제되더라도 뷰는 자동적으로 삭제되지 않는다.
ⓒ DBA는 보안 측면에서 뷰를 활용할 수 있다.
ⓓ 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에는 제약이 따른다.


ⓐ, ⓑ, ⓒ, ⓓ
ⓐ, ⓒ, ⓓ
ⓑ, ⓓ
ⓒ, ⓓ ✅ 정답/입력한 답

> 💡 **해설:** 각 항목의 옳고 그름을 분석하면 다음과 같다.
> - **ⓐ 틀림:** 뷰는 물리적으로 저장되지 않는다. 뷰는 논리적 정의(SELECT 쿼리)만 저장되며, 실제 데이터는 기본 테이블에 존재한다. (단, Materialized View는 예외)
> - **ⓑ 틀림:** 기본 테이블이 삭제되면 그 테이블을 기반으로 한 뷰도 자동으로 삭제된다.
> - **ⓒ 맞음:** DBA는 민감한 컬럼을 제외한 뷰를 생성하여 보안 정책을 구현할 수 있다.
> - **ⓓ 맞음:** 뷰에 대한 DML 연산(INSERT, UPDATE, DELETE)은 특정 조건(기본 키 포함 여부, 집계 함수 사용 여부 등)에 따라 제약이 따른다.
>
> 옳은 내용은 **ⓒ, ⓓ**이다.


43번. 관계 해석에 대한 설명으로 옳지 않은 것은?

수학의 프레디킷 해석에 기반을 두고 있다.
관계 데이터 모델의 제안자인 코드(Codd)가 관계 데이터베이스에 적용할 수 있도록 설계하여 제안하였다.
튜플 관계 해석과 도메인 관계 해석이 있다.
원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 특성을 가진다. ✅ 정답/입력한 답

> 💡 **해설:** 관계 해석(Relational Calculus)과 관계 대수(Relational Algebra)의 차이점:
> - **관계 해석:** **비절차적(Non-procedural)** 언어. "**무엇(What)**을 원하는가"를 기술하며, 데이터를 어떻게 유도하는지는 기술하지 않는다.
> - **관계 대수:** **절차적(Procedural)** 언어. "**어떻게(How)** 유도하는가"를 기술한다.
>
> 따라서 "원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 **절차적** 특성을 가진다"는 설명은 관계 **대수**의 특성을 관계 해석으로 잘못 기술한 것이므로 옳지 않다. 정답은 마지막 보기이다.


44번. 트랜잭션 특성 중 둘 이상의 트랜잭션이 병행 실행 시 다른 트랜잭션의 연산이 끼어들 수 없음을 의미하는 것은?

Log
Consistency
Isolation ✅ 정답/입력한 답
Durability

> 💡 **해설:** 트랜잭션의 4가지 특성(ACID)은 다음과 같다.
> - **원자성(Atomicity):** 트랜잭션의 연산은 모두 성공하거나 모두 실패해야 함 (All or Nothing)
> - **일관성(Consistency):** 트랜잭션 실행 전후에 데이터베이스의 일관성이 유지되어야 함
> - **격리성/독립성(Isolation):** 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음
> - **영속성/지속성(Durability):** 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함
>
> "다른 트랜잭션의 연산이 끼어들 수 없음"은 **Isolation(격리성)**이다.


45번. 관계 해석에서 'for all: 모든 것에 대하여'의 의미를 나타내는 논리 기호는?

∃
∈
∀ ✅ 정답/입력한 답
∪

> 💡 **해설:** 관계 해석에서 사용하는 논리 기호:
> - **∀ (Universal Quantifier):** "모든 것에 대하여(for all)"를 의미하는 전칭 한정자
> - **∃ (Existential Quantifier):** "존재한다(there exists)"를 의미하는 존재 한정자
> - **∈:** 집합의 원소 관계를 나타냄
> - **∪:** 합집합(Union)을 나타냄
>
> 정답은 **∀**이다.


46번. 다음 BETWEEN 연산의 의미와 동일한 것은? 점수 BETWEEN 90 AND 95

점수 >= 90 AND 점수 <= 95 ✅ 정답/입력한 답
점수 > 90 AND 점수 < 95
점수 > 90 AND 점수 <= 95
점수 >= 90 AND 점수 < 95

> 💡 **해설:** SQL의 **BETWEEN ... AND ...** 연산자는 양 끝값을 **포함(inclusive)**하는 범위 조건이다.
>
> `점수 BETWEEN 90 AND 95`는 `점수 >= 90 AND 점수 <= 95`와 동일하다.
>
> 즉, 90 이상 95 이하(90과 95를 포함)인 값을 검색한다. 정답은 **점수 >= 90 AND 점수 <= 95**이다.


47번. 병행 제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?

데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.
로킹 단위가 작아지면 로킹 오버헤드가 감소한다. ✅ 정답/입력한 답
로킹 단위가 작아지면 데이터베이스 공유도가 증가한다.
한꺼번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 한다.

> 💡 **해설:** 로킹(Locking) 단위와 특성의 관계:
>
> | 로킹 단위 | 오버헤드 | 공유도 | 병행성 |
> |-----------|----------|--------|--------|
> | 크면 | 감소 | 감소 | 감소 |
> | 작으면 | **증가** | 증가 | 증가 |
>
> **"로킹 단위가 작아지면 로킹 오버헤드가 감소한다"는 설명은 틀렸다.** 로킹 단위가 작아질수록 관리해야 할 잠금의 수가 증가하므로 오버헤드는 **증가**한다. 따라서 이 보기가 옳지 않은 것이다.


48번. DROP VIEW V_1 CASCADE; 명령 수행 후 결과로 옳은 것은?

V_1만 삭제된다.
V_2만 삭제된다.
V_1과 V_2 모두 삭제된다. ✅ 정답/입력한 답
V_1과 V_2 모두 삭제되지 않는다.

> 💡 **해설:** SQL의 **DROP VIEW** 명령에서 옵션에 따른 동작:
> - **CASCADE:** 삭제할 뷰를 참조하는 다른 뷰나 객체도 연쇄적으로 함께 삭제
> - **RESTRICT:** 삭제할 뷰를 참조하는 객체가 있으면 삭제 거부
>
> `DROP VIEW V_1 CASCADE;`를 실행하면 V_1과 V_1을 참조하는 V_2도 함께 삭제된다. 정답은 **V_1과 V_2 모두 삭제된다**이다.


49번. 제2정규형에서 제3정규형이 되기 위한 조건은?

이행적 함수 종속 제거 ✅ 정답/입력한 답
부분적 함수 종속 제거
다치 종속 제거
결정자이면서 후보키가 아닌 것 제거

> 💡 **해설:** 정규화 단계별 조건:
>
> | 정규형 | 조건 |
> |--------|------|
> | 1NF → 2NF | 부분적 함수 종속 제거 |
> | **2NF → 3NF** | **이행적 함수 종속 제거** |
> | 3NF → BCNF | 결정자이면서 후보키가 아닌 것 제거 |
> | BCNF → 4NF | 다치 종속 제거 |
> | 4NF → 5NF | 조인 종속성 제거 |
>
> **이행적 함수 종속**이란 A → B이고 B → C일 때 A → C가 성립하는 관계이다. 제3정규형은 이행적 함수 종속을 제거한 형태이다. 정답은 **이행적 함수 종속 제거**이다.


50번. 시스템 카탈로그에 대한 설명으로 틀린 것은?

시스템 카탈로그의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다. ✅ 정답/입력한 답
데이터베이스에 포함되는 데이터 객체에 대한 정의나 명세에 대한 정보를 유지 관리한다.
DBMS가 스스로 생성하고 유지하는 데이터베이스 내의 특별한 테이블 집합체이다.
카탈로그에 저장된 정보를 메타 데이터라고도 한다.

> 💡 **해설:** **시스템 카탈로그(System Catalog)**는 데이터베이스에 대한 데이터(메타 데이터)를 저장하는 특별한 테이블 집합체로, DBMS가 자동으로 생성하고 유지 관리한다.
>
> **"SQL을 이용하여 사용자가 직접 갱신하여야 한다"는 설명은 틀렸다.** 시스템 카탈로그는 사용자가 직접 갱신할 수 없으며, DBMS가 DDL 명령(CREATE, ALTER, DROP 등) 실행 시 자동으로 갱신한다. 사용자가 직접 수정하면 데이터베이스 무결성이 깨질 수 있다.
>
> 정답은 첫 번째 보기이다.

---

# 2026년 1회 정보처리기사 필기시험(복원) - 51번~80번

> 점수: 88.0점

---

**51번.** 다음 중 데이터베이스 무결성(Integrity) 제약 조건에 대한 설명으로 옳은 것은?

1. **개체 무결성(Entity Integrity): 기본키(Primary Key)를 구성하는 어떤 속성값도 널(NULL) 값이나 중복값을 가질 수 없다는 규정이다.** ✅ 정답 / 입력한 답
2. 참조 무결성(Referential Integrity): 속성값들이 사용자가 정의한 제약 조건(예: 특정 범위의 값)을 만족해야 한다는 규정이다.
3. 도메인 무결성(Domain Integrity): 외래키(Foreign Key) 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 반드시 일치해야 한다는 규정이다.
4. 사용자 정의 무결성(User-Defined Integrity): 특정 속성의 값이 그 속성에 정의된 도메인(범위)에 속한 값이어야 한다는 규정이다.

> 💡 **해설:** 데이터베이스 무결성 제약 조건의 종류와 정의를 구분하는 문제입니다.
> - **개체 무결성(Entity Integrity)**: 기본키를 구성하는 속성은 NULL 값이나 중복값을 가질 수 없습니다. (1번 - 올바른 설명)
> - **참조 무결성(Referential Integrity)**: 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 일치해야 합니다. (2번은 사용자 정의 무결성의 설명)
> - **도메인 무결성(Domain Integrity)**: 특정 속성의 값이 그 속성에 정의된 도메인 범위에 속해야 합니다. (3번은 참조 무결성의 설명)
> - **사용자 정의 무결성(User-Defined Integrity)**: 사용자가 정의한 비즈니스 규칙을 만족해야 합니다. (4번은 도메인 무결성의 설명)
> 선택지 2~4번은 설명이 서로 뒤바뀌어 있으므로, 1번이 유일하게 올바른 설명입니다.

---

**52번.** 다음 중 데이터베이스 키(Key)의 정의와 특징이 바르게 연결된 것은?

1. **슈퍼키(Super Key): 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는 속성 또는 속성들의 집합이다.** ✅ 정답 / 입력한 답
2. 기본키(Primary Key): 후보키 중에서 특별히 선정된 키로, 중복된 값을 가질 수 있으며 상황에 따라 널(NULL) 값을 허용한다.
3. 대체키(Alternate Key): 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말하며, 유일성은 만족하지만 최소성은 만족하지 않는다.
4. 외래키(Foreign Key): 하나의 릴레이션 내에서 각 튜플을 유일하게 식별할 수 있는 속성으로, 반드시 자기 자신의 릴레이션 내에서만 정의되어야 한다.

> 💡 **해설:** 데이터베이스 키의 종류와 특성을 구분하는 문제입니다.
> - **슈퍼키(Super Key)**: 유일성만 만족, 최소성은 만족하지 않아도 됩니다. (1번 - 올바른 설명)
> - **기본키(Primary Key)**: 후보키 중 선정된 키로, NULL과 중복값 모두 불가합니다. (2번 설명은 틀림)
> - **대체키(Alternate Key)**: 후보키 중 기본키를 제외한 나머지로, 유일성과 최소성 모두 만족합니다. (3번에서 '최소성 만족하지 않는다'가 틀림)
> - **외래키(Foreign Key)**: 다른 릴레이션의 기본키를 참조하는 속성입니다. (4번 설명은 후보키에 대한 설명)
> 키의 특성: 후보키 = 유일성 + 최소성, 슈퍼키 = 유일성만 만족

---

**53번.** 다음 중 트랜잭션의 상태(Transaction State)에 대한 설명으로 가장 옳지 않은 것은?

1. 활동(Active): 트랜잭션이 시작되어 현재 실행 중인 상태를 의미한다.
2. 완료(Committed): 트랜잭션이 성공적으로 종료되어 연산 결과를 데이터베이스에 최종적으로 반영(Commit)한 상태이다.
3. **부분 완료(Partially Committed): 트랜잭션의 마지막 연산 바로 직전의 상태로, Commit 연산이 실행되기 전의 상태이다.** ✅ 정답 / 입력한 답
4. 철회(Aborted): 트랜잭션 수행 중 오류가 발생하여 수행이 중단되고, 실행 전 상태로 돌아가기 위해 Rollback 연산을 수행한 상태이다.

> 💡 **해설:** 트랜잭션 상태 전이에 관한 문제입니다.
> 3번 설명이 틀린 이유: **부분 완료(Partially Committed)**는 트랜잭션의 마지막 연산이 실행된 **직후**의 상태입니다. 즉, 마지막 연산 수행은 완료되었지만 아직 Commit이 실행되기 전의 상태를 말합니다. 문제에서 "마지막 연산 바로 직전"이라고 한 것이 오류입니다.
> - Active(활동) → Partially Committed(부분 완료) → Committed(완료) 순으로 전이되며,
> - 오류 발생 시 Active 또는 Partially Committed 상태에서 Failed(실패) → Aborted(철회)로 전이됩니다.

---

**54번.** 트랜잭션의 특성 중 틀린 것은?

1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
2. **둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 있다.** ✅ 정답 / 입력한 답
3. 트랜잭션에 의해서 생성된 결과는 계속 유지되어야 한다.
4. 트랜잭션의 연산을 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

> 💡 **해설:** 트랜잭션의 ACID 특성에 관한 문제입니다.
> - 1번: **일관성(Consistency)** - 트랜잭션 수행 전후 데이터베이스 상태가 일관성을 유지해야 합니다. (올바른 설명)
> - 2번: **격리성(Isolation)** - 병행 실행 시 다른 트랜잭션이 끼어들 수 없어야 합니다. "끼어들 수 있다"는 표현이 틀린 설명입니다. (정답)
> - 3번: **지속성(Durability)** - 성공적으로 완료된 트랜잭션의 결과는 영구히 보존됩니다. (올바른 설명)
> - 4번: **원자성(Atomicity)** - 트랜잭션 연산은 전부 실행되거나 전혀 실행되지 않아야 합니다(All or Nothing). (올바른 설명)

---

**55번.** 외래키(Foreign Key)에 대한 설명으로 옳지 않은 것은?

1. **외래키는 하나의 릴레이션에 존재하는 후보키들 중에서 기본키를 제외한 나머지 후보키들을 의미한다.** ✅ 정답 / 입력한 답
2. 외래키는 현실 세계에서 존재하는 개체타입들 간의 관계를 표현하는데 중요한 역할을 수행한다.
3. 관계형 데이터 모델에서 한 릴레이션의 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션간에 참조 관계를 표현하는 중요한 도구이다.
4. 외래키를 포함하는 릴레이션이 참조하는 릴레이션이 되고, 대응하는 기본키를 포함하는 릴레이션이 참조 릴레이션이 된다.

> 💡 **해설:** 외래키(Foreign Key)의 정의에 관한 문제입니다.
> 1번 설명은 **대체키(Alternate Key)**의 정의입니다. 대체키는 후보키 중에서 기본키를 제외한 나머지 후보키들을 말합니다.
> **외래키(Foreign Key)**는 한 릴레이션의 속성이 다른 릴레이션의 기본키를 참조하는 속성(또는 속성들의 집합)입니다. 외래키는 NULL이거나 참조하는 릴레이션의 기본키 값과 같아야 합니다(참조 무결성).

---

**56번.** 정규화에 관한 설명으로 옳지 않은 것은?

1. 릴레이션 R의 도메인들의 값이 원자값만을 가지면 릴레이션 R은 제1정규형에 해당된다.
2. **릴레이션 R이 제2정규형을 만족하고, 결정자 이면서 후보키가 아닌 것을 제거하면 제3정규형에 해당된다.** ✅ 정답 / 입력한 답
3. 릴레이션 R이 제1정규형을 만족하면서, 키가 아닌 모든 속성들이 기본키에 완전 함수 종속이면 릴레이션 R은 제2정규형에 해당된다.
4. 정규형들은 차수가 높아질수록(제1정규형→제5정규형) 만족시켜야 할 제약조건이 많아진다.

> 💡 **해설:** 정규화 단계에 관한 문제입니다.
> 2번 설명은 **BCNF(Boyce-Codd Normal Form)**의 정의입니다. BCNF는 모든 결정자가 후보키여야 하는 조건으로, "결정자이면서 후보키가 아닌 것을 제거"하는 것은 BCNF 달성 방법입니다.
> **제3정규형(3NF)**은 제2정규형을 만족하면서, 기본키가 아닌 모든 속성이 기본키에 대해 **이행적 함수 종속(Transitive Functional Dependency)**을 갖지 않는 것입니다. (A→B→C 에서 A→C를 제거)
> - 1NF: 원자값만 존재
> - 2NF: 1NF + 부분 함수 종속 제거 (완전 함수 종속)
> - 3NF: 2NF + 이행적 함수 종속 제거
> - BCNF: 3NF + 모든 결정자가 후보키

---

**57번.** 관계 해석에 대한 설명으로 틀린 것은? ❌ 오답

1. 튜플 관계 해석과 도메인 관계 해석이 있다.
2. **질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시해야 하는 절차적인 언어이다.** ✅ 정답
3. ~~릴레이션을 정의하는 방법을 제공한다.~~ ← 입력한 답
4. 수학의 프레디킷 해석(Predicate Calculus)에 기반을 두고 있다.

> ❌ 오답: 입력=③릴레이션을 정의하는 방법을 제공한다. / 정답=②절차적인 언어이다.

> 💡 **해설:** 관계 해석(Relational Calculus)의 특성에 관한 문제입니다.
> **관계 해석은 비절차적(Non-Procedural) 언어**입니다. 원하는 결과가 무엇인지(What)만 기술하고, 어떻게 구하는지(How)는 명시하지 않습니다. 2번에서 "수행해야 할 연산의 순서를 명시해야 하는 절차적인 언어"라는 설명이 틀린 부분입니다.
> 반면 **관계 대수(Relational Algebra)**는 절차적 언어로, 연산의 순서를 명시합니다.
> - 관계 해석: 비절차적, 수학의 프레디킷 해석 기반, 튜플 관계 해석/도메인 관계 해석으로 구분
> - ③번 "릴레이션을 정의하는 방법을 제공한다"는 관계 해석의 실제 기능으로 올바른 설명입니다.

---

**58번.** 물리 데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?

1. 범위 분할(Range Partitioning)
2. 해시 분할(Hash Partitioning)
3. 조합 분할(Composite Partitioning)
4. **유닛 분할(Unit Processing)** ✅ 정답 / 입력한 답

> 💡 **해설:** 데이터베이스 파티션 유형에 관한 문제입니다.
> 표준 파티션 유형으로는 다음이 있습니다:
> - **범위 분할(Range Partitioning)**: 지정한 열의 값 범위를 기준으로 분할 (예: 날짜 범위)
> - **해시 분할(Hash Partitioning)**: 해시 함수를 적용한 결과값으로 분할
> - **목록 분할(List Partitioning)**: 지정한 열의 특정 값 목록을 기준으로 분할
> - **조합 분할(Composite Partitioning)**: 두 가지 이상의 분할 방법을 조합하여 사용
> - **라운드 로빈 분할(Round-Robin Partitioning)**: 균등하게 순환하며 분할
> **유닛 분할(Unit Processing)**은 파티션 유형으로 존재하지 않습니다.

---

**59번.** 다음 SQL 문에서 ( ) 안에 들어갈 내용으로 옳은 것은?
```sql
UPDATE 인사급여 ( ) 호봉=15 WHERE 성명='홍길동';
```
❌ 오답

1. **SET** ✅ 정답
2. ~~FROM~~ ← 입력한 답
3. INTO
4. IN

> ❌ 오답: 입력=②FROM / 정답=①SET

> 💡 **해설:** SQL UPDATE 문법에 관한 문제입니다.
> UPDATE 문의 기본 문법: `UPDATE 테이블명 SET 열명=값 [WHERE 조건]`
> - `UPDATE`: 데이터 수정 명령어
> - `SET`: 수정할 열과 값을 지정하는 키워드
> - `WHERE`: 수정 대상 행을 지정하는 조건절
> FROM은 SELECT문에서 테이블을 지정할 때 사용하는 키워드이고, INTO는 INSERT문에서 사용합니다.

---

**60번.** 참조 무결성을 유지하기 위하여 DROP 문에서 부모 테이블의 항목 값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?

1. CLUSTER
2. **CASCADE** ✅ 정답 / 입력한 답
3. SET-NULL
4. RESTRICTED

> 💡 **해설:** 참조 무결성 제약 조건의 삭제/갱신 옵션에 관한 문제입니다.
> 외래키의 참조 무결성 옵션:
> - **CASCADE**: 부모 테이블의 행이 삭제/변경되면 자식 테이블의 해당 행도 자동으로 삭제/변경됩니다.
> - **SET NULL**: 부모 테이블의 행이 삭제/변경되면 자식 테이블의 해당 외래키 값을 NULL로 설정합니다.
> - **RESTRICT(RESTRICTED)**: 자식 테이블에 참조하는 행이 있으면 부모 테이블의 삭제/변경을 거부합니다.
> - **NO ACTION**: 참조 무결성을 위반하는 작업을 허용하지 않습니다.
> CLUSTER는 인덱스 관련 옵션으로 참조 무결성과 관련이 없습니다.

---

**61번.** C언어에서 사용할 수 없는 변수명은?

1. student2019
2. **text-color** ✅ 정답 / 입력한 답
3. _korea
4. amount

> 💡 **해설:** C언어 식별자(변수명) 명명 규칙에 관한 문제입니다.
> C언어 식별자 규칙:
> - 영문자(a-z, A-Z), 숫자(0-9), 언더스코어(_)만 사용 가능
> - 숫자로 시작 불가
> - 키워드(예약어) 사용 불가
> - 대소문자 구분
> `text-color`에서 하이픈(-)은 C언어에서 뺄셈 연산자로 해석되므로, `text-color`는 변수명으로 사용할 수 없습니다. 이 표현식은 `text - color` (text에서 color를 빼는 연산)으로 해석됩니다.

---

**62번.** 다음 c언어 프로그램이 실행되었을 때, 실행 결과는?
```c
#include <stdio.h>
int main(int argc, char *argv[ ]) {
    int a = 1, b= 2
    int r = (++a, a++, b++);
    printf("%d", r);
    return 0;
}
```

1. 1
2. **2** ✅ 정답 / 입력한 답
3. 3
4. 4

> 💡 **해설:** C언어 쉼표(comma) 연산자와 전위/후위 증가 연산자에 관한 문제입니다.
> 쉼표 연산자는 왼쪽부터 순서대로 각 표현식을 평가하고, 마지막 표현식의 값을 반환합니다.
> `r = (++a, a++, b++)` 실행 과정:
> 1. `++a`: a가 1→2로 증가 (전위 연산, a=2)
> 2. `a++`: 현재 a=2를 읽고 a가 2→3으로 증가 (후위 연산, a=3). 이 값(2)은 쉼표 연산자에 의해 버려짐
> 3. `b++`: 현재 b=2를 읽고 b가 2→3으로 증가 (후위 연산). 이 값(2)이 r에 대입됨
> 따라서 `r = 2`, `printf("%d", r)`의 출력은 **2**

---

**63번.** 파이썬에서 여러 자료를 한 번에 저장하는 자료형으로만 묶인 것은?

1. int, float, str
2. float, bool, list
3. bool, tuple, set
4. **list, set, tuple** ✅ 정답 / 입력한 답

> 💡 **해설:** 파이썬 컨테이너(자료 모음) 자료형에 관한 문제입니다.
> 파이썬의 단일 값 자료형: `int`, `float`, `str`, `bool`
> 파이썬의 컨테이너(여러 자료 저장) 자료형:
> - **list**: 순서 있음, 변경 가능 (mutable), 중복 허용 예) `[1, 2, 3]`
> - **tuple**: 순서 있음, 변경 불가 (immutable), 중복 허용 예) `(1, 2, 3)`
> - **set**: 순서 없음, 변경 가능, 중복 불허 예) `{1, 2, 3}`
> - **dict**: 키-값 쌍, 변경 가능 예) `{'a': 1}`
> `str`은 문자들의 시퀀스이지만 여러 자료형을 저장하는 것이 아닌 문자열 자료형으로 분류합니다.

---

**64번.** 3개의 프레임을 수용할 수 있는 주기억 장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우, 페이지 결함의 발생 횟수는?

페이지 참조 순서 : 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0

1. 13
2. **14** ✅ 정답 / 입력한 답
3. 15
4. 20

> 💡 **해설:** FIFO(First In First Out) 페이지 교체 알고리즘에 관한 문제입니다.
> FIFO는 가장 오래된 페이지를 교체합니다. 프레임 수 = 3
>
> | 참조 | 프레임 상태 | 결함 |
> |------|------------|------|
> | 7 | [7] | ○ |
> | 0 | [7,0] | ○ |
> | 1 | [7,0,1] | ○ |
> | 2 | [0,1,2] | ○ (7 교체) |
> | 0 | [0,1,2] | - |
> | 3 | [1,2,3] | ○ (0 교체) |
> | 0 | [2,3,0] | ○ (1 교체) |
> | 4 | [3,0,4] | ○ (2 교체) |
> | 2 | [0,4,2] | ○ (3 교체) |
> | 3 | [4,2,3] | ○ (0 교체) |
> | 0 | [2,3,0] | ○ (4 교체) |
> | 3 | [2,3,0] | - |
> | 2 | [2,3,0] | - |
> | 1 | [3,0,1] | ○ (2 교체) |
> | 2 | [0,1,2] | ○ (3 교체) |
> | 0 | [0,1,2] | - |
> | 1 | [0,1,2] | - |
> | 7 | [1,2,7] | ○ (0 교체) |
> | 0 | [2,7,0] | ○ (1 교체) |
>
> 총 페이지 결함 횟수: **14회**

---

**65번.** 교착상태 발생의 필요 충분 조건이 아닌 것은?

1. 상호배제(Mutual Exclusion)
2. 점유와 대기(Hold and Wait)
3. 환형 대기(Circular Wait)
4. **선점(Preemption)** ✅ 정답 / 입력한 답

> 💡 **해설:** 교착상태(Deadlock) 발생의 필요 조건(코프만 조건)에 관한 문제입니다.
> 교착상태 발생의 4가지 필요 충분 조건:
> 1. **상호배제(Mutual Exclusion)**: 자원은 한 번에 하나의 프로세스만 사용 가능
> 2. **점유와 대기(Hold and Wait)**: 자원을 점유한 채로 다른 자원을 기다림
> 3. **비선점(Non-Preemption)**: 점유 중인 자원을 강제로 빼앗을 수 없음
> 4. **환형 대기(Circular Wait)**: 프로세스들이 원형으로 서로의 자원을 기다림
> **선점(Preemption)**이 가능하면 교착상태를 방지할 수 있습니다. 교착상태 조건은 **비선점**이며, 선점은 교착상태 조건이 아닙니다.

---

**66번.** TCP/IP 네트워크에서 IP 주소를 MAC 주소로 변환하는 프로토콜은?

1. UDP
2. **ARP** ✅ 정답 / 입력한 답
3. TCP
4. ICMP

> 💡 **해설:** 주소 변환 프로토콜에 관한 문제입니다.
> - **ARP(Address Resolution Protocol)**: IP 주소 → MAC 주소로 변환
> - **RARP(Reverse ARP)**: MAC 주소 → IP 주소로 변환
> - **ICMP(Internet Control Message Protocol)**: 인터넷 제어 메시지 프로토콜, 오류 보고 및 진단(ping)
> - **UDP(User Datagram Protocol)**: 비연결형 전송 계층 프로토콜
> - **TCP(Transmission Control Protocol)**: 연결형 전송 계층 프로토콜
> ARP는 네트워크 계층(IP)에서 데이터링크 계층(MAC)으로 주소를 변환하여 실제 통신이 가능하게 합니다.

---

**67번.** IP 주소와 호스트 이름 간의 변환을 제공하는 시스템은?

1. **DNS** ✅ 정답 / 입력한 답
2. NFS
3. Router
4. Modem

> 💡 **해설:** 네트워크 서비스에 관한 문제입니다.
> - **DNS(Domain Name System)**: 도메인 이름(호스트 이름)을 IP 주소로 변환(정방향) 또는 IP 주소를 도메인 이름으로 변환(역방향)하는 계층적 분산 데이터베이스 시스템입니다. 기본 포트: UDP 53번
> - **NFS(Network File System)**: 네트워크를 통해 파일 시스템을 공유하는 시스템
> - **Router**: 네트워크 간 패킷을 전달하는 장비
> - **Modem**: 디지털 신호를 아날로그 신호로 변환(또는 그 반대)하는 장비

---

**68번.** 다음 중 프로토콜의 포트 번호가 올바르지 않은 것은?

1. TFTP - UDP 69
2. SNMP - UDP 161
3. **RPC - TCP 112** ✅ 정답 / 입력한 답
4. TELNET - TCP 23

> 💡 **해설:** 주요 프로토콜 포트 번호에 관한 문제입니다.
> **RPC(Remote Procedure Call)**의 표준 포트 번호는 **111번** (TCP/UDP)입니다. 문제에서 112번이라고 한 것이 틀린 내용입니다.
> 주요 포트 번호 정리:
> - FTP: TCP 20(데이터), 21(제어)
> - SSH: TCP 22
> - TELNET: TCP 23
> - SMTP: TCP 25
> - DNS: UDP 53
> - HTTP: TCP 80
> - SNMP: UDP 161
> - TFTP: UDP 69
> - RPC: TCP/UDP 111

---

**69번.** 다음 중 C Class에 속하는 IP Address는?

1. **200.168.30.1** ✅ 정답 / 입력한 답
2. 10.3.2.1
3. 225.2.4.1
4. 172.16.98.3

> 💡 **해설:** IP 주소 클래스 구분에 관한 문제입니다.
> IP 주소 클래스는 첫 번째 옥텟(8비트) 값으로 구분합니다:
> - **Class A**: 0~127 (예: 10.3.2.1 → A 클래스)
> - **Class B**: 128~191 (예: 172.16.98.3 → B 클래스)
> - **Class C**: 192~223 (예: 200.168.30.1 → C 클래스) ← 정답
> - **Class D**: 224~239 (예: 225.2.4.1 → D 클래스, 멀티캐스트용)
> - **Class E**: 240~255 (예약)
> 200은 192~223 범위에 해당하므로 Class C입니다.

---

**70번.** 빈 기억 공간에 크기가 20KB, 16KB, 8KB, 40KB일 때 기억 장치 배치 전략으로 "Best Fit"을 사용하여 17KB의 프로그램을 적재할 경우 내부 단편화의 크기는 얼마인가?

1. **3KB** ✅ 정답 / 입력한 답
2. 23KB
3. 64KB
4. 67KB

> 💡 **해설:** 메모리 배치 전략(Best Fit)에 관한 문제입니다.
> 기억 장치 배치 전략:
> - **First Fit(최초 적합)**: 수용 가능한 첫 번째 공간에 배치
> - **Best Fit(최적 적합)**: 수용 가능한 공간 중 가장 작은 공간에 배치 → 남는 공간(단편화) 최소화
> - **Worst Fit(최악 적합)**: 수용 가능한 공간 중 가장 큰 공간에 배치
>
> 17KB 프로그램을 Best Fit으로 배치:
> - 20KB: 17KB 수용 가능, 남는 공간 3KB
> - 16KB: 17KB 수용 불가 (너무 작음)
> - 8KB: 17KB 수용 불가 (너무 작음)
> - 40KB: 17KB 수용 가능, 남는 공간 23KB
>
> Best Fit → 남는 공간이 가장 작은 **20KB** 공간 선택
> 내부 단편화 = 20KB - 17KB = **3KB**

---

**71번.** JAVA의 예외(Exception)와 관련된 설명으로 틀린 것은?

1. **문법 오류로 인해 발생한 것** ✅ 정답 / 입력한 답
2. 오동작이나 결과에 악영향을 미칠 수 있는 실행시간 동안에 발생한 오류
3. 배열의 인덱스가 그 범위를 넘어서는 경우 발생하는 오류
4. 존재하지 않는 파일을 읽으려고 하는 경우에 발생하는 오류

> 💡 **해설:** Java 예외(Exception)의 특성에 관한 문제입니다.
> **Java 예외(Exception)**는 프로그램 **실행 중(Runtime)**에 발생하는 오류 상황입니다.
> **문법 오류(Syntax Error)**는 컴파일 타임에 발견되는 오류로, Java 예외가 아닌 **컴파일 에러**입니다.
> Java 예외의 예시:
> - `ArrayIndexOutOfBoundsException`: 배열 인덱스 초과 (3번)
> - `FileNotFoundException`: 파일 없음 (4번)
> - `NullPointerException`: null 참조
> - `ClassCastException`: 잘못된 형 변환
> - `ArithmeticException`: 0으로 나누기
> Java 예외 계층: `Throwable` → `Error` / `Exception` → `RuntimeException` / `CheckedException`

---

**72번.** SSH(Secure Shell)에 대한 설명으로 틀린 것은?

1. **SSH의 기본 네트워크 포트는 220번을 사용한다.** ✅ 정답 / 입력한 답
2. 전송되는 데이터는 암호화된다.
3. 키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 한다.
4. 서로 연결되어 있는 컴퓨터 간 원격 명령 실행이나 쉘 서비스 등을 수행한다.

> 💡 **해설:** SSH(Secure Shell) 프로토콜에 관한 문제입니다.
> **SSH의 기본 포트 번호는 22번**입니다. 220번이라는 설명이 틀린 내용입니다.
> SSH의 특징:
> - 기본 포트: **TCP 22번**
> - 암호화된 보안 원격 접속 프로토콜 (Telnet의 보안 버전)
> - 전송되는 모든 데이터가 암호화됨
> - 공개키 기반 인증: 클라이언트의 공개키(Public Key)를 서버의 `~/.ssh/authorized_keys`에 등록
> - 원격 명령 실행, 파일 전송(SCP, SFTP), 터널링 기능 지원

---

**73번.** 오류 제어에 사용되는 자동반복 요청방식(ARQ)이 아닌 것은? ❌ 오답

1. Stop-and-wait ARQ
2. Go-back-N ARQ
3. ~~Selective-Repeat ARQ~~ ← 입력한 답
4. **Non-Acknowledge ARQ** ✅ 정답

> ❌ 오답: 입력=③Selective-Repeat ARQ / 정답=④Non-Acknowledge ARQ

> 💡 **해설:** ARQ(Automatic Repeat reQuest) 방식의 종류에 관한 문제입니다.
> 표준 ARQ 방식 3가지:
> - **Stop-and-Wait ARQ**: 프레임 하나를 전송하고 ACK를 받을 때까지 대기. 단순하지만 효율 낮음
> - **Go-Back-N ARQ**: 오류 발생 프레임부터 N개 모두 재전송
> - **Selective-Repeat ARQ (선택적 반복)**: 오류 발생 프레임만 선택하여 재전송. 효율이 가장 높음
> **Non-Acknowledge ARQ**는 표준 ARQ 방식으로 존재하지 않는 개념입니다.
> Selective-Repeat ARQ는 실제 존재하는 방식이므로 정답이 될 수 없습니다.

---

**74번.** 자바 프로그램이 실행되었을 때, 실행 결과는?
```java
public class Main{
    public static void main(String[] args){
        int[] c = {500, 100, 50, 10};
        int m = 6790;
        int a = 0;
        for (int i = 0; i < c.length; i++){
            int cnt = m/c[i]
            a += cnt;
            m = m - cnt*c[i];
        }
        System.out.printf("%d", a);
    }
}
```

1. 4
2. **20** ✅ 정답 / 입력한 답
3. 420
4. 894

> 💡 **해설:** Java 정수 나눗셈과 반복문에 관한 문제입니다. 거스름돈 계산 알고리즘입니다.
> 초기값: m=6790, a=0
>
> | i | c[i] | cnt = m/c[i] | a += cnt | m -= cnt*c[i] |
> |---|------|--------------|----------|----------------|
> | 0 | 500 | 6790/500=13 | a=13 | m=6790-6500=290 |
> | 1 | 100 | 290/100=2 | a=15 | m=290-200=90 |
> | 2 | 50 | 90/50=1 | a=16 | m=90-50=40 |
> | 3 | 10 | 40/10=4 | a=20 | m=40-40=0 |
>
> 최종 출력: **20**

---

**75번.** IPv6의 주소체계로 거리가 먼 것은?

1. 유니캐스트
2. 애니캐스트
3. **브로드캐스트** ✅ 정답 / 입력한 답
4. 멀티캐스트

> 💡 **해설:** IPv6 주소 유형에 관한 문제입니다.
> **IPv6의 3가지 주소 유형**:
> - **유니캐스트(Unicast)**: 단일 인터페이스(1:1 통신)
> - **애니캐스트(Anycast)**: 여러 인터페이스 중 가장 가까운 하나에게 전달(1:1, 그룹 중 최단 경로)
> - **멀티캐스트(Multicast)**: 특정 그룹의 모든 인터페이스에 전달(1:N)
>
> **브로드캐스트(Broadcast)**는 **IPv4에서만 지원**되는 주소 유형입니다. IPv6에서는 브로드캐스트를 사용하지 않으며, 그 기능을 멀티캐스트가 대체합니다.

---

**76번.** C언어에서 비트 논리 연산자에 해당하지 않는 것은?

1. ^
2. **?** ✅ 정답 / 입력한 답
3. &
4. ~

> 💡 **해설:** C언어의 비트 연산자 종류에 관한 문제입니다.
> C언어의 비트(Bitwise) 연산자:
> - `&`: 비트 AND
> - `|`: 비트 OR
> - `^`: 비트 XOR (1번 - 비트 연산자)
> - `~`: 비트 NOT (1의 보수) (4번 - 비트 연산자)
> - `<<`: 왼쪽 시프트
> - `>>`: 오른쪽 시프트
>
> **`?`**는 **삼항(조건) 연산자**(`조건 ? 참_값 : 거짓_값`)로, 비트 연산자가 아닙니다.

---

**77번.** C언어에서 두 개의 논릿값 중 하나라도 참이면 1을, 모두 거짓이면 0을 반환하는 연산자는?

1. **||** ✅ 정답 / 입력한 답
2. &&
3. **
4. !=

> 💡 **해설:** C언어의 논리 연산자에 관한 문제입니다.
> 하나라도 참이면 1을 반환 → 논리 OR 연산
> - **`||`**: 논리 OR - 피연산자 중 하나라도 참(0이 아님)이면 1, 모두 거짓(0)이면 0 반환 (정답)
> - **`&&`**: 논리 AND - 두 피연산자 모두 참이면 1, 하나라도 거짓이면 0 반환
> - **`!=`**: 부등 비교 연산자 - 두 값이 다르면 1, 같으면 0 반환
> - `**`는 C언어에서 지원하지 않는 연산자입니다 (파이썬의 거듭제곱 연산자)

---

**78번.** 객체지향 프로그래밍의 장점으로 거리가 먼 것은? ❌ 오답

1. ~~자연적인 모델링이 가능하다.~~ ← 입력한 답
2. 소프트웨어의 재사용율이 높아진다.
3. 소프트웨어의 유지보수성이 향상된다.
4. **실행속도가 빨라진다.** ✅ 정답

> ❌ 오답: 입력=①자연적인 모델링이 가능하다. / 정답=④실행속도가 빨라진다.

> 💡 **해설:** 객체지향 프로그래밍(OOP)의 장단점에 관한 문제입니다.
> **객체지향 프로그래밍의 장점**:
> - 자연적인 모델링이 가능 (현실 세계를 객체로 모델링)
> - 소프트웨어 재사용성 향상 (클래스, 상속)
> - 유지보수성 향상 (캡슐화, 모듈화)
> - 대형 프로젝트에 적합
>
> **객체지향 프로그래밍의 단점**:
> - **실행 속도가 느림** (절차지향에 비해 오버헤드 발생 - 동적 바인딩, 가상 함수 테이블 등)
> - 설계가 복잡함
> - 처리 속도가 절차적 언어보다 느릴 수 있음
>
> 따라서 "실행속도가 빨라진다"는 객체지향의 단점에 해당하여 장점이 아닙니다.

---

**79번.** 다음 C언어 프로그램이 실행되었을 때의 결과는?
```c
#include <stdio.h>
int main(int argc, char *argv[]){
    int a = 4;
    int b = 7;
    int c = a | b;
    printf("%d", c);
    return 0;
}
```

1. 3
2. 4
3. **7** ✅ 정답 / 입력한 답
4. 10

> 💡 **해설:** C언어의 비트 OR 연산에 관한 문제입니다.
> `a | b` = 비트 OR 연산
> - a = 4 → 이진수: `0100`
> - b = 7 → 이진수: `0111`
> - a | b → `0100` | `0111` = `0111` = 7
>
> 비트 OR는 대응하는 비트 중 하나라도 1이면 1을 반환합니다.
> 따라서 `c = 7`, `printf("%d", c)` 출력: **7**
> (참고로 `a & b` = `0100` & `0111` = `0100` = 4)

---

**80번.** 다음 Python 프로그램의 실행 결과가 [실행 결과]와 같을 때, 빈칸에 적합한 것은?
```python
x = 20
if x == 10:
    print('10')
( ) x == 20:
    print('20')
else:
    print('other')
```
[실행 결과] 20

1. either
2. **elif** ✅ 정답 / 입력한 답
3. else if
4. else

> 💡 **해설:** Python 조건문 문법에 관한 문제입니다.
> Python의 다중 조건문 구조:
> ```python
> if 조건1:
>     실행문1
> elif 조건2:      # else if의 Python 축약 키워드
>     실행문2
> else:
>     실행문3
> ```
> - `elif`: Python에서 "else if"를 의미하는 키워드 (정답)
> - `else if`: Java, C, JavaScript 등에서 사용하는 문법 (Python에서는 사용 불가)
> - `either`: 존재하지 않는 키워드
> - `else`: 조건 없이 나머지 경우를 처리 (elif처럼 조건식을 가질 수 없음)
> x=20이고 `elif x == 20` 조건이 참이므로 '20'이 출력됩니다.

---

## 오답 정리 (51번~80번)

| 번호 | 주제 | 입력한 답 | 정답 |
|------|------|----------|------|
| 57번 | 관계 해석 | ③릴레이션을 정의하는 방법을 제공한다. | ②절차적인 언어이다. |
| 59번 | SQL UPDATE 구문 | ②FROM | ①SET |
| 73번 | ARQ 방식 | ③Selective-Repeat ARQ | ④Non-Acknowledge ARQ |
| 78번 | 객체지향 프로그래밍 장점 | ①자연적인 모델링이 가능하다. | ④실행속도가 빨라진다. |

---

# 2026년 1회 정보처리기사 필기시험(복원) - 81번~100번

> 점수: 88.0점

---

**81번.** 다음 내용이 설명하는 것은?

- 사물 통신, 사물 인터넷과 같이 대역폭이 제한된 통신환경에 최적화하여 개발된 푸시기술 기반의 경량 메시지 전송 프로토콜
- 메시지 매개자(Broker)를 통해 송신자가 특정 메시지를 발행하고 수신자가 메시지를 구독하는 방식
- IBM이 주도하여 개발

1. GRID
2. TELNET
3. GPN
4. **MQTT** ✅ 정답 / 입력한 답

> 💡 **해설:** MQTT(Message Queuing Telemetry Transport)는 IBM이 개발한 경량 메시지 전송 프로토콜이다. Publish/Subscribe(발행/구독) 구조를 사용하며, 메시지 브로커(Broker)가 중간에서 메시지를 중계한다. 대역폭이 제한된 IoT 환경에 최적화되어 있으며, TCP/IP 기반으로 동작한다. GRID는 분산 컴퓨팅 기술, TELNET은 원격 접속 프로토콜이므로 오답이다.

---

**82번.** COCOMO Model 중 기관 내부에서 개발된 중소 규모의 소프트웨어로 일괄 자료 처리나 과학 기술 계산용, 비즈니스 자료 처리용으로 5만 라인 이하의 소프트웨어를 개발하는 유형은?

1. Embedded
2. **Organic** ✅ 정답 / 입력한 답
3. Semi-detached
4. Semi-embedded

> 💡 **해설:** COCOMO(COnstructive COst MOdel)는 소프트웨어 개발 비용 산정 모델로, 세 가지 유형으로 분류된다. Organic(단순형)은 5만 라인 이하의 소규모 소프트웨어로 기관 내부 개발에 적합하다. Semi-detached(반분리형)는 30만 라인 이하의 중간 규모이며, Embedded(내재형)는 30만 라인 이상의 대규모로 하드웨어와 실시간 처리가 필요한 시스템에 해당한다. Semi-embedded는 존재하지 않는 유형이다.

---

**83번.** 프로토타이핑 모형(Prototyping Model)에 대한 설명으로 옳지 않은 것은?

1. **개발단계에서 오류 수정이 불가하므로 유지보수비용이 많이 발생한다.** ✅ 정답 / 입력한 답
2. 최종 결과물이 만들어지기 전에 의뢰자가 최종 결과물의 일부 혹은 모형을 볼 수 있다.
3. 프로토타입은 발주자나 개발자 모두에게 공동의 참조 모델을 제공한다.
4. 프로토타입은 구현 단계의 구현 골격이 될 수 있다.

> 💡 **해설:** 프로토타이핑 모형은 개발 초기에 시제품(Prototype)을 만들어 사용자의 요구사항을 확인하고 반영하는 방식이다. 이 모형의 핵심 장점은 개발 단계에서 오류를 조기에 발견하고 수정할 수 있다는 것이다. 따라서 1번의 "오류 수정이 불가"하다는 설명은 옳지 않다(이것이 정답). 나머지 보기들은 프로토타이핑 모형의 올바른 특징이다. 단, 프로토타이핑 모형의 단점으로는 프로토타입 제작에 시간과 비용이 소모되고, 완성품으로 오인될 수 있다는 점이 있다.

---

**84번.** 기존 무선 랜의 한계 극복을 위해 등장하였으며, 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신, 홈네트워킹, 공공안전 등의 특수목적을 위한 새로운 방식의 네트워크 기술을 의미하는 것은? ❌ 오답

1. Software Defined Perimeter
2. Virtual Private Network
3. ~~Local Area Network~~ ← 입력한 답
4. **Mesh Network** ✅ 정답

> ❌ 오답: 입력=③Local Area Network / 정답=④Mesh Network

> 💡 **해설:** Mesh Network(메시 네트워크)는 모든 노드가 서로 연결되어 데이터를 릴레이 방식으로 전달하는 네트워크 구조이다. 기존 무선 랜(Wi-Fi)의 한계인 커버리지 제한을 극복하고, 대규모 IoT 디바이스 연결에 최적화되어 있다. 차세대 이동통신(5G), 홈네트워킹, 공공안전망(재난망) 등에 활용된다. LAN(Local Area Network)은 근거리 통신망을 의미하는 일반적인 네트워크 분류이므로 오답이다.

---

**85번.** 다음 설명에 해당하는 소프트웨어는?

- 개발해야 할 애플리케이션의 일부분이 이미 내장된 클래스 라이브러리로 구현되어 있다.
- 따라서, 그 기반이 되는 이미 존재하는 부분을 확장 및 이용하는 것으로 볼 수 있다.
- JAVA 기반의 대표적인 소프트웨어로는 스프링(Spring)이 있다.

1. 전역 함수 라이브러리
2. **소프트웨어 개발 프레임워크** ✅ 정답 / 입력한 답
3. 컨테이너 아키텍처
4. 어휘 분석기

> 💡 **해설:** 소프트웨어 개발 프레임워크(Framework)는 애플리케이션 개발에 필요한 공통적인 구조와 기능을 미리 구현해 놓은 재사용 가능한 틀이다. 라이브러리와의 차이점은, 라이브러리는 개발자가 필요할 때 호출하는 반면, 프레임워크는 제어의 역전(IoC)을 통해 프레임워크가 개발자의 코드를 호출한다. Java 기반의 Spring, Python 기반의 Django, JavaScript 기반의 Angular 등이 대표적인 프레임워크이다.

---

**86번.** 다음에서 설명하는 용어로 올바른 것은?

- 가상·초월과 세계·우주의 합성어로서, 3차원 가상 세계를 뜻하는 용어이다.
- 가상 병원 등 현실에도 이용되는 기술이다.

1. **메타버스(Metaverse)** ✅ 정답 / 입력한 답
2. 증강 현실(Augmented Reality)
3. 포스퀘어(Foursquare)
4. 매시업(Mashup)

> 💡 **해설:** 메타버스(Metaverse)는 '초월'을 의미하는 Meta와 '세계·우주'를 의미하는 Universe의 합성어로, 현실과 가상이 융합된 3차원 디지털 세계를 의미한다. 1992년 닐 스티븐슨의 소설 "Snow Crash"에서 처음 등장한 개념이다. 증강현실(AR)은 현실에 가상 정보를 덧씌우는 기술이며, 포스퀘어(Foursquare)는 위치 기반 소셜 네트워크 서비스, 매시업(Mashup)은 여러 서비스를 조합하여 새로운 서비스를 만드는 기술이므로 오답이다.

---

**87번.** 다음 내용이 설명하는 것은?

- 블록체인 개발 환경을 클라우드로 서비스하는 개념.
- 블록체인 네트워크에 노드의 추가 및 제거가 용이.
- 블록체인의 기본 인프라를 추상화하여 블록체인 응용 프로그램을 만들 수 있는 클라우드 컴퓨팅 플랫폼

1. OTT
2. **BaaS** ✅ 정답 / 입력한 답
3. SDDC
4. Wi-SUN

> 💡 **해설:** BaaS(Blockchain as a Service)는 블록체인 기술을 클라우드 서비스 형태로 제공하는 개념이다. 개발자가 블록체인 인프라를 직접 구축하지 않고도 블록체인 기반 애플리케이션을 개발할 수 있도록 지원한다. Microsoft Azure, AWS, IBM Cloud 등에서 BaaS를 제공한다. 참고로 BaaS는 Backend as a Service를 의미하기도 하는데, 이 문제에서는 블록체인 관련 설명이므로 Blockchain as a Service가 정확한 의미이다. OTT(Over The Top)는 인터넷 기반 동영상 서비스, SDDC(Software Defined Data Center)는 소프트웨어 정의 데이터센터이므로 오답이다.

---

**88번.** 취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?

1. **서버 관리실 출입 통제** ✅ 정답 / 입력한 답
2. 실행 프로세스 권한 설정
3. 운영체제의 접근 제한
4. 운영체제의 정보 수집 제한

> 💡 **해설:** 문제는 "응용 프로그램의 보안 설정"과 거리가 먼 것을 묻고 있다. 실행 프로세스 권한 설정, 운영체제의 접근 제한, 운영체제의 정보 수집 제한은 모두 소프트웨어적 보안 설정에 해당한다. 반면 "서버 관리실 출입 통제"는 물리적(Physical) 보안에 해당하므로 응용 프로그램의 보안 설정과 가장 거리가 멀다. 보안은 물리적 보안, 관리적 보안, 기술적 보안으로 구분되며, 출입 통제는 물리적 보안 영역이다.

---

**89번.** 기기를 키오스크에 갖다 대면 원하는 데이터를 바로 가져올 수 있는 기술로 10cm 이내 근접 거리에서 기가급 속도로 데이터 전송이 가능한 초고속 근접 무선 통신(NFC; Near Field Communication) 기술은?

1. BcN(Broadband Convergence Network)
2. **Zing** ✅ 정답 / 입력한 답
3. Marine Navi
4. C-V2X(Cellular Vehicle To Everything)

> 💡 **해설:** Zing은 한국전자통신연구원(ETRI)이 개발한 초고속 근접 무선 통신 기술로, 10cm 이내의 근거리에서 기가급(수 Gbps) 속도로 대용량 데이터를 전송할 수 있다. 기존 NFC(Near Field Communication)가 수십 kbps~수백 kbps 수준인 것에 비해 월등히 빠른 속도를 제공한다. BcN은 광대역 통합망, C-V2X는 차량-사물 간 통신 기술이므로 오답이다.

---

**90번.** 다음 암호 알고리즘 중 성격이 다른 하나는?

1. MD4
2. MD5
3. SHA-1
4. **AES** ✅ 정답 / 입력한 답

> 💡 **해설:** MD4, MD5, SHA-1은 모두 해시(Hash) 알고리즘으로, 임의 길이의 입력 데이터를 고정 길이의 해시값으로 변환하는 단방향 암호화 방식이다. 반면 AES(Advanced Encryption Standard)는 대칭키(비밀키) 암호화 알고리즘으로, 암호화와 복호화 모두 가능한 양방향 방식이다. MD5는 128비트, SHA-1은 160비트 해시값을 생성하며, AES는 128/192/256비트 키를 사용하는 블록 암호화 방식이다.

---

**91번.** 다음 중 호스트 컴퓨터와 저장 장치를 직접 연결하는 DAS(Direct Attached Storage) 방식에서 사용되는 프로토콜이 아닌 것은?

1. SCSI (Small Computer System Interface)
2. SAS (Serial Attached SCSI)
3. eSATA (External Serial Advanced Technology Attachment)
4. **iSCSI (Internet Small Computer System Interface)** ✅ 정답 / 입력한 답

> 💡 **해설:** DAS(Direct Attached Storage)는 서버와 저장장치를 직접 케이블로 연결하는 방식이다. SCSI, SAS, eSATA는 모두 DAS 방식에서 사용되는 직접 연결 인터페이스이다. 반면 iSCSI(Internet SCSI)는 TCP/IP 네트워크를 통해 SCSI 명령을 전달하는 프로토콜로, NAS나 SAN(Storage Area Network) 환경에서 사용되는 네트워크 기반 스토리지 프로토콜이다. 따라서 DAS 방식의 프로토콜이 아닌 것은 iSCSI이다.

---

**92번.** 시스템의 사용자가 로그인하여 명령을 내리는 과정에 대한 시스템의 동작 중 다음 설명에 해당하는 것은?
*(사용자가 자신이 누구인지를 시스템에 알리는 과정 - 로그인 시 ID/PW 확인)*

1. Aging
2. Accounting
3. Authorization
4. **Authentication** ✅ 정답 / 입력한 답

> 💡 **해설:** 보안의 3A 개념을 이해해야 한다. Authentication(인증)은 사용자가 자신이 누구인지를 시스템에 알리고 확인하는 과정(ID/PW 확인)이다. Authorization(인가/권한부여)은 인증된 사용자가 어떤 자원에 접근할 수 있는지 권한을 확인하는 과정이다. Accounting(계정관리/감사)은 사용자의 행위를 기록하고 추적하는 과정이다. Aging은 패스워드 정책에서 일정 기간이 지나면 패스워드를 변경하도록 강제하는 기능이다.

---

**93번.** 애플리케이션 개발/테스트/배포에 필요한 플랫폼을 제공해서 개발자는 인프라 관리 없이 코드에 집중할 수 있는 서비스는?

1. IaaS
2. BaaS
3. SaaS
4. **PaaS** ✅ 정답 / 입력한 답

> 💡 **해설:** 클라우드 서비스 모델은 크게 세 가지로 구분된다. IaaS(Infrastructure as a Service)는 가상화된 컴퓨팅 자원(서버, 스토리지, 네트워크)을 제공한다. PaaS(Platform as a Service)는 애플리케이션 개발, 테스트, 배포에 필요한 플랫폼(개발 환경, 미들웨어 등)을 제공하며, 개발자는 인프라 관리 없이 코드 작성에만 집중할 수 있다. SaaS(Software as a Service)는 완성된 소프트웨어를 인터넷을 통해 제공한다. 대표적인 PaaS로는 Google App Engine, Heroku, Microsoft Azure App Service가 있다.

---

**94번.** 다음 중 빅데이터랑 연관 없는 것은? ❌ 오답

1. Hadoop
2. R
3. ~~NoSQL~~ ← 입력한 답
4. **LMS** ✅ 정답

> ❌ 오답: 입력=③NoSQL / 정답=④LMS

> 💡 **해설:** Hadoop은 대용량 데이터의 분산 처리를 위한 오픈소스 프레임워크로 빅데이터 분석의 핵심 기술이다. R은 통계 분석과 데이터 시각화를 위한 프로그래밍 언어로 빅데이터 분석에 널리 사용된다. NoSQL은 비관계형 데이터베이스로, 빅데이터의 비정형 데이터 저장 및 처리에 활용된다. LMS(Learning Management System)는 학습 관리 시스템으로, 온라인 교육 플랫폼(e-러닝)에서 학습자와 콘텐츠를 관리하는 시스템이다. 빅데이터 기술과는 직접적인 관련이 없으므로 정답이다.

---

**95번.** 다음에서 설명하는 기술은?

인공지능의 분야 중 하나로, 인간의 학습 능력과 같은 기능을 컴퓨터에서 실현하고자 하는 기술이며, 환경과의 상호작용에 기반한 경험적인 데이터로부터 스스로 성능을 향상시키는 시스템을 연구하는 기술이다.

1. **기계학습** ✅ 정답 / 입력한 답
2. 블록체인
3. SOA
4. RPA

> 💡 **해설:** 기계학습(Machine Learning)은 인공지능의 하위 분야로, 명시적인 프로그래밍 없이 데이터로부터 패턴을 학습하여 스스로 성능을 향상시키는 기술이다. 지도학습(Supervised Learning), 비지도학습(Unsupervised Learning), 강화학습(Reinforcement Learning)으로 구분된다. 블록체인은 분산 원장 기술, SOA(Service Oriented Architecture)는 서비스 지향 아키텍처, RPA(Robotic Process Automation)는 업무 자동화 기술이므로 오답이다.

---

**96번.** 프로그램의 설계도의 하나인 NS Chart에 대한 설명으로 가장 거리가 먼 것은?

1. 논리의 기술에 중점을 두고 도형을 이용한 표현 방법이다.
2. 연속, 선택 및 다중 선택 반복 등의 제어논리 구조로 표현한다.
3. **주로 화살표를 사용하여 논리적인 제어 구조로 흐름을 표현한다.** ✅ 정답 / 입력한 답
4. 연속, 선택, 반복 등의 제어 논리 구조를 표현한다.

> 💡 **해설:** NS Chart(Nassi-Shneiderman Chart, 나씨-슈나이더만 차트)는 구조적 프로그래밍의 기본 제어 구조를 도형으로 표현하는 설계 도구이다. NS Chart의 핵심 특징은 화살표(Arrow)를 사용하지 않는다는 점이다. 화살표를 사용하면 GOTO 문 같은 비구조적 흐름이 생길 수 있기 때문이다. 대신 중첩된 직사각형 블록으로 순차, 선택(if/case), 반복(while/for) 구조를 표현한다. 따라서 "화살표를 사용"한다는 3번이 옳지 않은 설명이다. 참고로 화살표를 사용하는 것은 순서도(Flowchart)의 특징이다.

---

**97번.** 다음 중 간트 차트(Gantt Chart)의 구성 요소 및 특징으로 올바르지 않은 것은?

1. 이정표 (Milestone)
2. 작업 일정
3. 작업 기간
4. **작업 간의 상호 관련성** ✅ 정답 / 입력한 답

> 💡 **해설:** 간트 차트(Gantt Chart)는 프로젝트 일정 관리를 위한 막대 그래프 형태의 도구로, 이정표(Milestone), 작업 일정, 작업 기간, 담당자 등을 시각적으로 표현한다. 간트 차트의 대표적인 단점은 작업 간의 선후 관계(상호 관련성, 의존성)를 명확하게 표현하기 어렵다는 점이다. 작업 간의 상호 관련성(의존성)을 표현하는 데는 PERT/CPM(네트워크 차트) 기법이 더 적합하다. 따라서 "작업 간의 상호 관련성"은 간트 차트의 특징이 아니라 한계점이므로 올바르지 않은 것이 정답이다.

---

**98번.** 다음 설명에 해당하는 공격 기법은?

시스템 공격 기법 중 하나로 허용범위 이상의 ICMP 패킷을 전송하여 대상 시스템의 네트워크를 마비시킨다.

1. **Ping of Death** ✅ 정답 / 입력한 답
2. Session Hijacking
3. Piggyback Attack
4. XSS

> 💡 **해설:** Ping of Death(죽음의 핑)는 ICMP 패킷을 IP 최대 허용 크기(65,535 바이트)를 초과하여 전송함으로써 대상 시스템을 다운시키는 DoS(Denial of Service) 공격 기법이다. 대용량 패킷이 분할되어 전송되면 수신 측에서 재조합 시 버퍼 오버플로우가 발생한다. Session Hijacking은 이미 인증된 세션을 가로채는 공격, Piggyback Attack은 인가된 사용자를 따라 무단 접근하는 공격, XSS(Cross-Site Scripting)는 악성 스크립트를 웹페이지에 삽입하는 공격이다.

---

**99번.** 다음 설명에 해당하는 네트워크 인증 프로토콜은? ❌ 오답

대칭키 암호 방식을 기반으로 신뢰된 제3자(KDC)를 통해 사용자와 서버 간 상호 인증을 수행하며, 비밀번호를 네트워크상에 직접 전송하지 않고 '티켓(Ticket)'을 사용하여 인증하는 방식

1. RADIUS
2. ~~Oauth~~ ← 입력한 답
3. **Kerberos** ✅ 정답
4. SAML

> ❌ 오답: 입력=②Oauth / 정답=③Kerberos

> 💡 **해설:** Kerberos는 MIT에서 개발한 네트워크 인증 프로토콜로, 대칭키 암호화와 신뢰된 제3자인 KDC(Key Distribution Center)를 통해 상호 인증을 수행한다. 티켓(Ticket) 기반으로 동작하며, 비밀번호를 네트워크에 직접 전송하지 않아 도청 공격에 강하다. Windows Active Directory의 기본 인증 프로토콜로 사용된다. RADIUS는 원격 접근 인증 서버 프로토콜, OAuth는 제3자 애플리케이션에 대한 접근 권한 위임 프로토콜(SNS 로그인 등), SAML은 XML 기반의 인증/권한 데이터 교환 표준이다.

---

**100번.** 다음 내용이 설명하는 접근제어 모델은?

- 군대의 보안 레벨처럼 정보의 기밀성에 따라 상하 관계가 구분된 정보를 보호하기 위해 사용
- 자신의 권한보다 낮은 보안 레벨 권한을 가진 경우에는 높은 보안 레벨의 문서를 읽을 수 없고 자신의 권한보다 낮은 수준의 문서만 읽을 수 있다.
- 자신의 권한보다 높은 보안 레벨의 문서에는 쓰기가 가능하지만, 보안 레벨이 낮은 문서의 쓰기 권한은 제한한다.

1. Clark Wilson Integrity Model
2. PDCA Model
3. **Bell-Lapadula Model** ✅ 정답 / 입력한 답
4. Chinese Wall Model

> 💡 **해설:** Bell-LaPadula 모델은 미국 국방부(DoD)의 지원으로 개발된 MAC(Mandatory Access Control, 강제적 접근 제어) 모델로, 기밀성(Confidentiality) 보호에 중점을 둔다. 두 가지 핵심 원칙이 있다. No Read Up(단순 보안 속성): 자신보다 높은 보안 등급의 문서는 읽을 수 없다. No Write Down(스타 속성, *-property): 자신보다 낮은 보안 등급의 문서에는 쓸 수 없다(기밀 정보가 낮은 등급으로 유출되는 것을 방지). Clark-Wilson 모델은 무결성(Integrity) 보호 모델이며, Chinese Wall 모델은 이해충돌 방지 모델이다.

---

## 오답 정리 (81번~100번)

| 번호 | 주제 | 입력한 답 | 정답 |
|------|------|----------|------|
| 84번 | 네트워크 기술 | ③Local Area Network | ④Mesh Network |
| 94번 | 빅데이터 연관 기술 | ③NoSQL | ④LMS |
| 99번 | 네트워크 인증 프로토콜 | ②Oauth | ③Kerberos |

---

## 전체 오답 정리 (1번~100번)

| 번호 | 주제 | 입력한 답 | 정답 |
|------|------|----------|------|
| 5번 | CASE 기능 | ①그래픽지원 | ③언어번역 |
| 12번 | 애자일 기법 | ②crystal | ④spice |
| 40번 | 테스트 오라클 | ①테스트케이스 | ③테스트오라클 |
| 57번 | 관계 해석 | ③릴레이션을 정의하는 방법 | ②절차적인 언어이다 |
| 59번 | SQL UPDATE 구문 | ②FROM | ①SET |
| 73번 | ARQ 방식 | ③Selective-Repeat ARQ | ④Non-Acknowledge ARQ |
| 78번 | 객체지향 프로그래밍 장점 | ①자연적인 모델링 가능 | ④실행속도가 빨라진다 |
| 84번 | 네트워크 기술 | ③Local Area Network | ④Mesh Network |
| 94번 | 빅데이터 연관 기술 | ③NoSQL | ④LMS |
| 99번 | 네트워크 인증 프로토콜 | ②Oauth | ③Kerberos |

> **참고**: 기록된 오답 10개 중 점수는 88.0점 (12개 오답). 나머지 2개 오답은 Q1~50에서 확인 필요.
