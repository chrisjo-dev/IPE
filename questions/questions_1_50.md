
21번. 소프트웨어 재공학의 주요 활동 중 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업을 의미하는 것은?

Analysis
Migration ✅ 정답/입력한 답
Restructuring
Reverse Engineering

> 💡 **해설:** 소프트웨어 재공학의 주요 활동은 다음과 같다.
> - **Analysis(분석):** 기존 소프트웨어의 명세서를 확인하고 재공학 대상을 선정하는 단계
> - **Migration(이식):** 기존 소프트웨어를 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업
> - **Restructuring(재구조화):** 기존 소프트웨어를 다시 설계하거나 코드를 재작성하는 작업
> - **Reverse Engineering(역공학):** 기존 소프트웨어를 분석하여 소프트웨어 개발 초기 단계 결과물을 도출하는 작업
>
> 정답은 **Migration**이다.


22번. 알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?

단위 테스트
인수 테스트 ✅ 정답
통합 테스트 ← 입력한 답 (O 표시 → 정답과 동일 처리됨)
시스템 테스트


※ 22번은 답안 목록에서 O로 표시됨. 텍스트 배치 상 2번이 정답, 입력한 답도 정답으로 처리된 것으로 보임.

> 💡 **해설:** **알파(Alpha) 테스트**와 **베타(Beta) 테스트**는 모두 **인수 테스트(Acceptance Test)**의 유형이다.
> - **알파 테스트:** 개발자 환경에서 통제된 상태로 사용자가 수행하는 테스트
> - **베타 테스트:** 실제 사용자 환경에서 불특정 다수의 사용자가 수행하는 테스트
>
> 인수 테스트는 시스템이 사용자 요구 사항을 충족하는지 검증하는 최종 단계 테스트이며, 알파/베타 테스트는 그 대표적인 형태이다. 정답은 **인수 테스트**이다.


23번. 비선형 자료 구조에 해당하는 것은?

큐(Queue)
그래프(Graph) ✅ 정답/입력한 답
데크(Deque)
스택(Stack)

> 💡 **해설:** 자료 구조는 선형과 비선형으로 구분된다.
> - **선형 자료 구조:** 데이터가 일렬로 연결된 구조 → 배열, 연결 리스트, 스택(Stack), 큐(Queue), 데크(Deque)
> - **비선형 자료 구조:** 데이터가 계층적 또는 망 형태로 연결된 구조 → **트리(Tree), 그래프(Graph)**
>
> 큐, 데크, 스택은 선형 자료 구조이므로 비선형에 해당하는 것은 **그래프(Graph)**이다.


24번. 스택(Stack)에 대한 옳은 내용으로만 나열된 것은?

㉠ FIFO 방식으로 처리된다.
㉡ 순서 리스트의 뒤(Rear)에서 노드가 삽입되며, 앞(Front)에서 노드가 제거된다.
㉢ 선형 리스트의 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료 구조이다.
㉣ 인터럽트 처리, 서브루틴 호출 작업 등에 응용된다.


㉠, ㉡
㉡, ㉢
㉣ ✅ 정답/입력한 답
㉠, ㉡, ㉢, ㉣

> 💡 **해설:** 각 항목의 옳고 그름을 분석하면 다음과 같다.
> - **㉠ 틀림:** 스택은 **LIFO(Last In First Out)** 방식이다. FIFO는 큐(Queue)의 특성이다.
> - **㉡ 틀림:** Rear에서 삽입, Front에서 제거하는 것은 **큐(Queue)**의 특성이다. 스택은 한쪽 끝(Top)에서만 삽입·삭제가 이루어진다.
> - **㉢ 틀림:** 양쪽 끝에서 삽입과 삭제가 모두 가능한 것은 **데크(Deque)**의 특성이다.
> - **㉣ 맞음:** 스택은 인터럽트 처리, 서브루틴 호출, 수식 계산(후위 표기법), 되돌아가기(undo) 등에 활용된다.
>
> 따라서 옳은 내용은 **㉣**만 해당된다.


25번. 순서가 A, B, C, D로 정해진 입력자료를 Push, Push, Pop, Push, Push, Pop, Pop, Pop 순서로 스택 연산을 수행하는 경우 출력 결과는?

B D C A ✅ 정답/입력한 답
A B C D
B A C D
A B D C

> 💡 **해설:** 스택 연산을 순서대로 추적하면 다음과 같다.
>
> | 연산 | 동작 | 스택 상태 | 출력 |
> |------|------|-----------|------|
> | Push | A 삽입 | [A] | - |
> | Push | B 삽입 | [A, B] | - |
> | Pop | B 제거 | [A] | **B** |
> | Push | C 삽입 | [A, C] | - |
> | Push | D 삽입 | [A, C, D] | - |
> | Pop | D 제거 | [A, C] | **D** |
> | Pop | C 제거 | [A] | **C** |
> | Pop | A 제거 | [] | **A** |
>
> 출력 결과: **B D C A**


26번. 소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?

Brooks의 법칙
Boehm의 법칙
Pareto의 법칙 ✅ 정답/입력한 답
Jackson의 법칙

> 💡 **해설:** **파레토(Pareto)의 법칙**은 이탈리아 경제학자 빌프레도 파레토가 제안한 "80대 20 법칙"으로, 소프트웨어 테스트에서는 "오류의 80%가 전체 모듈의 20%에서 발견된다"는 원리로 적용된다. 이는 테스트 자원을 집중해야 할 영역을 선정하는 데 활용된다.
> - Brooks의 법칙: 지연된 프로젝트에 인력을 추가하면 오히려 더 지연된다.
> - Boehm의 법칙: 개발 초기에 결함을 발견할수록 수정 비용이 낮다.


27번. 블랙박스 테스트 기법으로 거리가 먼 것은?

기초 경로 검사 ✅ 정답/입력한 답
동치 클래스 분해
경곗값 분석
원인 결과 그래프

> 💡 **해설:** **블랙박스 테스트(Black Box Test)**는 소프트웨어의 내부 구조를 보지 않고 기능 중심으로 테스트하는 기법이다.
> - 블랙박스 기법: 동치 클래스 분해(동치 분할), 경곗값 분석, 원인 결과 그래프(cause-effect graphing), 오류 예측, 비교 검사 등
>
> **기초 경로 검사(Basic Path Testing)**는 제어 흐름 그래프를 이용해 프로그램 내부 논리 구조를 분석하는 **화이트박스(White Box) 테스트** 기법이다. 따라서 블랙박스 기법과 거리가 가장 멀다.


28번. 정렬된 n개의 데이터를 처리하는데 O(nlog₂n)의 시간이 소요되는 정렬 알고리즘은?

선택 정렬
삽입 정렬
버블 정렬
합병 정렬 ✅ 정답/입력한 답

> 💡 **해설:** 각 정렬 알고리즘의 시간 복잡도를 비교하면 다음과 같다.
>
> | 정렬 | 최선 | 평균 | 최악 |
> |------|------|------|------|
> | 선택 정렬 | O(n²) | O(n²) | O(n²) |
> | 삽입 정렬 | O(n) | O(n²) | O(n²) |
> | 버블 정렬 | O(n²) | O(n²) | O(n²) |
> | **합병 정렬** | **O(nlog₂n)** | **O(nlog₂n)** | **O(nlog₂n)** |
> | 퀵 정렬 | O(nlog₂n) | O(nlog₂n) | O(n²) |
>
> **합병 정렬(Merge Sort)**은 분할 정복 기법을 사용하며, 항상 O(nlog₂n)의 시간 복잡도를 보장한다. 정답은 **합병 정렬**이다.


29번. 인터페이스 구현 검증 도구가 아닌 것은?

Foxbase ✅ 정답/입력한 답
STAF
watir
xUnit

> 💡 **해설:** 인터페이스 구현 검증 도구에는 xUnit, STAF, FitNesse, NTAF, Selenium, Watir, Robot Framework 등이 있다.
> - **xUnit:** 다양한 언어를 지원하는 단위 테스트 프레임워크
> - **STAF:** 서비스 호출 및 컴포넌트 재사용 기반의 테스트 자동화 프레임워크
> - **Watir:** Ruby 기반의 웹 애플리케이션 테스트 자동화 도구
>
> **Foxbase**는 dBASE 호환 데이터베이스 관리 시스템(DBMS)으로, 인터페이스 구현 검증과 무관하다. 정답은 **Foxbase**이다.


30번. 다음 자료를 버블 정렬로 오름차순 정렬 시 PASS 2의 수행 결과는? (9, 6, 7, 3, 5)

3, 5, 6, 7, 9
6, 7, 3, 5, 9
3, 5, 9, 6, 7
6, 3, 5, 7, 9 ✅ 정답/입력한 답

> 💡 **해설:** 버블 정렬은 인접한 두 원소를 비교하여 큰 값을 뒤로 보내는 방식이다.
>
> 초기 상태: **9, 6, 7, 3, 5**
>
> **PASS 1** (가장 큰 값 9를 맨 뒤로):
> - 9↔6 → 6, 9, 7, 3, 5
> - 9↔7 → 6, 7, 9, 3, 5
> - 9↔3 → 6, 7, 3, 9, 5
> - 9↔5 → **6, 7, 3, 5, 9**
>
> **PASS 2** (두 번째로 큰 값 7을 뒤에서 두 번째로):
> - 6↔7 → 6, 7, 3, 5, 9 (변화 없음)
> - 7↔3 → 6, 3, 7, 5, 9
> - 7↔5 → **6, 3, 5, 7, 9**
>
> PASS 2 결과: **6, 3, 5, 7, 9**


31번. S/W Project 말기에 새로운 인원을 추가 투입하면 더욱 지연된다는 법칙은?

Putnam의 법칙
Mayer의 법칙
Brooks의 법칙 ✅ 정답/입력한 답
Boehm의 법칙

> 💡 **해설:** **Brooks의 법칙(Brook's Law)**은 프레더릭 브룩스가 저서 "맨먼스 미신(The Mythical Man-Month)"에서 제안한 법칙으로, "지연된 소프트웨어 프로젝트에 인력을 추가 투입하면 오히려 더 늦어진다"는 내용이다. 신규 인원의 교육 비용, 기존 인원과의 의사소통 오버헤드 증가 등이 주요 원인이다. 정답은 **Brooks의 법칙**이다.


32번. 결함 관리 프로세스 단계 설명으로 가장 적절하지 않은 것은?

결함 등록(Registration): 발견된 오류를 시스템에 기록하고 보고하는 단계
결함 검토(Review): 실제 오류인지, 중복 여부 분석하는 단계
결함 할당(Assignment): 검토된 결함 해결을 위해 담당자를 지정하는 단계
결함 수정(Correction): 할당된 결함 조치가 완료되어 '수정 완료' 상태가 된 것을 의미한다. ✅ 정답/입력한 답

> 💡 **해설:** 결함 관리 프로세스의 단계는 일반적으로 다음과 같다:
> 결함 등록 → 결함 검토 → 결함 할당 → **결함 수정** → 결함 재확인 → 결함 종료
>
> - 결함 수정(Correction) 단계는 담당자가 결함을 실제로 **수정하는 작업을 수행하는 단계**이지, 이미 완료된 상태를 의미하지 않는다.
> - "할당된 결함 조치가 완료되어 '수정 완료' 상태가 된 것"이라는 설명은 **결함 재확인(Re-test)** 또는 결함 종료 단계에 더 가깝다.
>
> 따라서 결함 수정에 대한 설명이 가장 적절하지 않다.


33번. 다음에서 설명하는 테스트의 종류는? (입력 조건에 타당/비타당 자료를 나누어 결과 확인)

equivalence partitioning test ✅ 정답/입력한 답
boundary value analysis
comparision testing
cause-effect graphing testing

> 💡 **해설:** **동치 분할 테스트(Equivalence Partitioning Test)**는 입력 데이터를 유사한 특성을 가진 그룹(동치 클래스)으로 분류하여 각 그룹에서 대표 값을 선택해 테스트하는 기법이다.
> - 유효 동치 클래스(Valid Equivalence Class): 타당한 입력값의 집합
> - 무효 동치 클래스(Invalid Equivalence Class): 비타당한 입력값의 집합
>
> 입력 조건에 대해 타당한 자료와 비타당한 자료를 나누어 테스트 케이스를 작성하는 기법이므로 정답은 **equivalence partitioning test**이다.


34번. 버전 관리 항목 중 저장소에 새로운 버전의 파일로 갱신하는 것을 의미하는 용어는?

형상 검사(Configuration Audit)
롤백(Rollback)
단위 테스트(Unit Test)
체크인(Check-In) ✅ 정답/입력한 답

> 💡 **해설:** 버전 관리 관련 주요 용어는 다음과 같다.
> - **체크인(Check-In):** 로컬에서 수정한 파일을 저장소(Repository)에 새로운 버전으로 갱신(업로드)하는 작업
> - **체크아웃(Check-Out):** 저장소에서 파일을 로컬로 가져오는 작업
> - **롤백(Rollback):** 소프트웨어를 이전 버전으로 되돌리는 작업
> - **형상 검사(Configuration Audit):** 형상 항목의 무결성을 검증하는 활동
>
> 정답은 **체크인(Check-In)**이다.


35번. 단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은?

알고리즘 오류에 따른 원치 않는 결과
탈출구가 없는 반복문의 사용
모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과 ✅ 정답/입력한 답
틀린 계산 수식에 의한 잘못된 결과

> 💡 **해설:** **단위 테스트(Unit Test)**는 개별 모듈(함수, 메서드)을 독립적으로 테스트하는 단계이다.
> 단위 테스트에서 발견 가능한 오류:
> - 알고리즘 오류
> - 무한 루프(탈출구 없는 반복문)
> - 잘못된 계산 수식
> - 데이터 타입 오류
> - 경계값 오류 등
>
> **모듈 간의 비정상적 상호작용**은 개별 모듈이 아닌 모듈들이 연결된 상태에서 발생하는 문제이므로, **통합 테스트(Integration Test)**에서 발견되는 오류에 해당한다.


36번. 선형 자료 구조에 해당하는 것은?

스택, 큐, 트리
큐, 데크, 스택 ✅ 정답/입력한 답
큐, 그래프
그래프, 리스트

> 💡 **해설:** 자료 구조의 분류:
> - **선형 자료 구조:** 배열(Array), 연결 리스트(Linked List), **스택(Stack), 큐(Queue), 데크(Deque)**
> - **비선형 자료 구조:** 트리(Tree), 그래프(Graph)
>
> 트리와 그래프는 비선형 자료 구조이므로, 선형 자료 구조만으로 구성된 것은 **큐, 데크, 스택**이다.


37번. 분할 정복에 기반한 알고리즘, 피벗을 사용하며 최악의 경우 N(N-1)/2회의 비교를 수행해야 하는 정렬은?

Selection Sort
Bubble Sort
Insert Sort
Quick Sort ✅ 정답/입력한 답

> 💡 **해설:** **퀵 정렬(Quick Sort)**의 특징:
> - **분할 정복(Divide and Conquer)** 기법을 사용
> - **피벗(Pivot)**을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분리
> - 평균 시간 복잡도: **O(nlog₂n)**
> - 최악의 경우(이미 정렬된 경우): **O(n²)** → N(N-1)/2회의 비교
> - 최악의 경우는 피벗이 항상 최솟값 또는 최댓값이 될 때 발생
>
> 정답은 **Quick Sort**이다.


38번. 단위 테스트에서 하위 모듈을 호출하고 파라미터를 전달하는 가상의 모듈로 상향식 테스트에 필요한 것은?

테스트 스텁(Test Stub)
테스트 드라이버(Test Driver) ✅ 정답/입력한 답
테스트 슈트(Test Suites)
테스트 케이스(Test Case)

> 💡 **해설:** 통합 테스트에서 사용하는 가상 모듈의 종류:
> - **테스트 드라이버(Test Driver):** 테스트 대상 모듈을 호출하고 파라미터를 전달하며 결과를 확인하는 상위 가상 모듈. **상향식(Bottom-Up) 통합 테스트**에서 사용
> - **테스트 스텁(Test Stub):** 테스트 대상 모듈이 호출하는 하위 가상 모듈. **하향식(Top-Down) 통합 테스트**에서 사용
>
> 문제에서 "하위 모듈을 호출하고 파라미터를 전달하는 가상의 모듈"이며 "상향식 테스트에 필요한 것"이라고 했으므로 정답은 **테스트 드라이버(Test Driver)**이다.


39번. 디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?

콘텐츠 암호화 및 키 관리
콘텐츠 식별체계 표현
콘텐츠 오류 감지 및 복구 ✅ 정답/입력한 답
라이선스 발급 및 관리

> 💡 **해설:** **디지털 저작권 관리(DRM, Digital Rights Management)**는 디지털 콘텐츠의 저작권 보호를 위한 기술로, 주요 구성 요소는 다음과 같다.
> - 콘텐츠 암호화 및 키 관리
> - 콘텐츠 식별체계 표현(메타데이터, DOI 등)
> - 라이선스 발급 및 관리
> - 패키저(Packager), 클리어링 하우스(Clearing House) 등
>
> **콘텐츠 오류 감지 및 복구**는 DRM의 기능이 아니라 데이터 무결성이나 오류 제어(RAID, 패리티 등)와 관련된 기술이다. 정답은 **콘텐츠 오류 감지 및 복구**이다.


40번. 다음이 설명하는 테스트 용어는? (사전에 정의된 참값을 입력하여 비교하는 기법, 참/샘플링/휴리스틱/일관성 검사 포함) ❌ 오답

테스트 케이스 ← 입력한 답
테스트 시나리오
테스트 오라클 ✅ 정답
테스트 데이터

> 💡 **해설:** **테스트 오라클(Test Oracle)**은 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값(예상 결과)과 실제 결과를 비교하는 메커니즘이다.
>
> 테스트 오라클의 유형:
> - **참(True) 오라클:** 모든 입력값에 대해 기대 결과를 확인
> - **샘플링(Sampling) 오라클:** 일부 입력값에 대해서만 기대 결과 확인
> - **휴리스틱(Heuristic) 오라클:** 경험적 원리로 기대 결과 확인
> - **일관성(Consistent) 검사 오라클:** 이전 실행 결과와 비교하여 일관성 확인
>
> 입력한 답인 **테스트 케이스**는 입력값, 실행 조건, 기대 결과를 정의한 문서로 오라클과는 다른 개념이다. 정답은 **테스트 오라클**이다.


41번. SQL 명령 중 그 성격이 나머지 셋과 다른 하나는?

CREATE ✅ 정답/입력한 답
SELECT
INSERT
UPDATE

> 💡 **해설:** SQL 명령어는 역할에 따라 분류된다.
> - **DDL(Data Definition Language):** CREATE, ALTER, DROP, TRUNCATE → 데이터베이스 구조(스키마) 정의
> - **DML(Data Manipulation Language):** SELECT, INSERT, UPDATE, DELETE → 데이터 조작
> - **DCL(Data Control Language):** GRANT, REVOKE → 권한 제어
>
> SELECT, INSERT, UPDATE는 모두 DML에 속하지만, **CREATE는 DDL**에 속하므로 성격이 다른 하나이다. 정답은 **CREATE**이다.


42번. 뷰(View)에 대한 옳은 내용으로만 나열한 것은?

ⓐ 뷰는 저장장치 내에 물리적으로 존재한다.
ⓑ 뷰가 정의된 기본 테이블이 삭제되더라도 뷰는 자동적으로 삭제되지 않는다.
ⓒ DBA는 보안 측면에서 뷰를 활용할 수 있다.
ⓓ 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에는 제약이 따른다.


ⓐ, ⓑ, ⓒ, ⓓ
ⓐ, ⓒ, ⓓ
ⓑ, ⓓ
ⓒ, ⓓ ✅ 정답/입력한 답

> 💡 **해설:** 각 항목의 옳고 그름을 분석하면 다음과 같다.
> - **ⓐ 틀림:** 뷰는 물리적으로 저장되지 않는다. 뷰는 논리적 정의(SELECT 쿼리)만 저장되며, 실제 데이터는 기본 테이블에 존재한다. (단, Materialized View는 예외)
> - **ⓑ 틀림:** 기본 테이블이 삭제되면 그 테이블을 기반으로 한 뷰도 자동으로 삭제된다.
> - **ⓒ 맞음:** DBA는 민감한 컬럼을 제외한 뷰를 생성하여 보안 정책을 구현할 수 있다.
> - **ⓓ 맞음:** 뷰에 대한 DML 연산(INSERT, UPDATE, DELETE)은 특정 조건(기본 키 포함 여부, 집계 함수 사용 여부 등)에 따라 제약이 따른다.
>
> 옳은 내용은 **ⓒ, ⓓ**이다.


43번. 관계 해석에 대한 설명으로 옳지 않은 것은?

수학의 프레디킷 해석에 기반을 두고 있다.
관계 데이터 모델의 제안자인 코드(Codd)가 관계 데이터베이스에 적용할 수 있도록 설계하여 제안하였다.
튜플 관계 해석과 도메인 관계 해석이 있다.
원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 특성을 가진다. ✅ 정답/입력한 답

> 💡 **해설:** 관계 해석(Relational Calculus)과 관계 대수(Relational Algebra)의 차이점:
> - **관계 해석:** **비절차적(Non-procedural)** 언어. "**무엇(What)**을 원하는가"를 기술하며, 데이터를 어떻게 유도하는지는 기술하지 않는다.
> - **관계 대수:** **절차적(Procedural)** 언어. "**어떻게(How)** 유도하는가"를 기술한다.
>
> 따라서 "원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 **절차적** 특성을 가진다"는 설명은 관계 **대수**의 특성을 관계 해석으로 잘못 기술한 것이므로 옳지 않다. 정답은 마지막 보기이다.


44번. 트랜잭션 특성 중 둘 이상의 트랜잭션이 병행 실행 시 다른 트랜잭션의 연산이 끼어들 수 없음을 의미하는 것은?

Log
Consistency
Isolation ✅ 정답/입력한 답
Durability

> 💡 **해설:** 트랜잭션의 4가지 특성(ACID)은 다음과 같다.
> - **원자성(Atomicity):** 트랜잭션의 연산은 모두 성공하거나 모두 실패해야 함 (All or Nothing)
> - **일관성(Consistency):** 트랜잭션 실행 전후에 데이터베이스의 일관성이 유지되어야 함
> - **격리성/독립성(Isolation):** 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음
> - **영속성/지속성(Durability):** 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함
>
> "다른 트랜잭션의 연산이 끼어들 수 없음"은 **Isolation(격리성)**이다.


45번. 관계 해석에서 'for all: 모든 것에 대하여'의 의미를 나타내는 논리 기호는?

∃
∈
∀ ✅ 정답/입력한 답
∪

> 💡 **해설:** 관계 해석에서 사용하는 논리 기호:
> - **∀ (Universal Quantifier):** "모든 것에 대하여(for all)"를 의미하는 전칭 한정자
> - **∃ (Existential Quantifier):** "존재한다(there exists)"를 의미하는 존재 한정자
> - **∈:** 집합의 원소 관계를 나타냄
> - **∪:** 합집합(Union)을 나타냄
>
> 정답은 **∀**이다.


46번. 다음 BETWEEN 연산의 의미와 동일한 것은? 점수 BETWEEN 90 AND 95

점수 >= 90 AND 점수 <= 95 ✅ 정답/입력한 답
점수 > 90 AND 점수 < 95
점수 > 90 AND 점수 <= 95
점수 >= 90 AND 점수 < 95

> 💡 **해설:** SQL의 **BETWEEN ... AND ...** 연산자는 양 끝값을 **포함(inclusive)**하는 범위 조건이다.
>
> `점수 BETWEEN 90 AND 95`는 `점수 >= 90 AND 점수 <= 95`와 동일하다.
>
> 즉, 90 이상 95 이하(90과 95를 포함)인 값을 검색한다. 정답은 **점수 >= 90 AND 점수 <= 95**이다.


47번. 병행 제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?

데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.
로킹 단위가 작아지면 로킹 오버헤드가 감소한다. ✅ 정답/입력한 답
로킹 단위가 작아지면 데이터베이스 공유도가 증가한다.
한꺼번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 한다.

> 💡 **해설:** 로킹(Locking) 단위와 특성의 관계:
>
> | 로킹 단위 | 오버헤드 | 공유도 | 병행성 |
> |-----------|----------|--------|--------|
> | 크면 | 감소 | 감소 | 감소 |
> | 작으면 | **증가** | 증가 | 증가 |
>
> **"로킹 단위가 작아지면 로킹 오버헤드가 감소한다"는 설명은 틀렸다.** 로킹 단위가 작아질수록 관리해야 할 잠금의 수가 증가하므로 오버헤드는 **증가**한다. 따라서 이 보기가 옳지 않은 것이다.


48번. DROP VIEW V_1 CASCADE; 명령 수행 후 결과로 옳은 것은?

V_1만 삭제된다.
V_2만 삭제된다.
V_1과 V_2 모두 삭제된다. ✅ 정답/입력한 답
V_1과 V_2 모두 삭제되지 않는다.

> 💡 **해설:** SQL의 **DROP VIEW** 명령에서 옵션에 따른 동작:
> - **CASCADE:** 삭제할 뷰를 참조하는 다른 뷰나 객체도 연쇄적으로 함께 삭제
> - **RESTRICT:** 삭제할 뷰를 참조하는 객체가 있으면 삭제 거부
>
> `DROP VIEW V_1 CASCADE;`를 실행하면 V_1과 V_1을 참조하는 V_2도 함께 삭제된다. 정답은 **V_1과 V_2 모두 삭제된다**이다.


49번. 제2정규형에서 제3정규형이 되기 위한 조건은?

이행적 함수 종속 제거 ✅ 정답/입력한 답
부분적 함수 종속 제거
다치 종속 제거
결정자이면서 후보키가 아닌 것 제거

> 💡 **해설:** 정규화 단계별 조건:
>
> | 정규형 | 조건 |
> |--------|------|
> | 1NF → 2NF | 부분적 함수 종속 제거 |
> | **2NF → 3NF** | **이행적 함수 종속 제거** |
> | 3NF → BCNF | 결정자이면서 후보키가 아닌 것 제거 |
> | BCNF → 4NF | 다치 종속 제거 |
> | 4NF → 5NF | 조인 종속성 제거 |
>
> **이행적 함수 종속**이란 A → B이고 B → C일 때 A → C가 성립하는 관계이다. 제3정규형은 이행적 함수 종속을 제거한 형태이다. 정답은 **이행적 함수 종속 제거**이다.


50번. 시스템 카탈로그에 대한 설명으로 틀린 것은?

시스템 카탈로그의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다. ✅ 정답/입력한 답
데이터베이스에 포함되는 데이터 객체에 대한 정의나 명세에 대한 정보를 유지 관리한다.
DBMS가 스스로 생성하고 유지하는 데이터베이스 내의 특별한 테이블 집합체이다.
카탈로그에 저장된 정보를 메타 데이터라고도 한다.

> 💡 **해설:** **시스템 카탈로그(System Catalog)**는 데이터베이스에 대한 데이터(메타 데이터)를 저장하는 특별한 테이블 집합체로, DBMS가 자동으로 생성하고 유지 관리한다.
>
> **"SQL을 이용하여 사용자가 직접 갱신하여야 한다"는 설명은 틀렸다.** 시스템 카탈로그는 사용자가 직접 갱신할 수 없으며, DBMS가 DDL 명령(CREATE, ALTER, DROP 등) 실행 시 자동으로 갱신한다. 사용자가 직접 수정하면 데이터베이스 무결성이 깨질 수 있다.
>
> 정답은 첫 번째 보기이다.
