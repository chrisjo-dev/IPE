# 2026년 1회 정보처리기사 필기시험(복원) - 51번~80번

> 점수: 88.0점

---

**51번.** 다음 중 데이터베이스 무결성(Integrity) 제약 조건에 대한 설명으로 옳은 것은?

1. **개체 무결성(Entity Integrity): 기본키(Primary Key)를 구성하는 어떤 속성값도 널(NULL) 값이나 중복값을 가질 수 없다는 규정이다.** ✅ 정답 / 입력한 답
2. 참조 무결성(Referential Integrity): 속성값들이 사용자가 정의한 제약 조건(예: 특정 범위의 값)을 만족해야 한다는 규정이다.
3. 도메인 무결성(Domain Integrity): 외래키(Foreign Key) 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 반드시 일치해야 한다는 규정이다.
4. 사용자 정의 무결성(User-Defined Integrity): 특정 속성의 값이 그 속성에 정의된 도메인(범위)에 속한 값이어야 한다는 규정이다.

> 💡 **해설:** 데이터베이스 무결성 제약 조건의 종류와 정의를 구분하는 문제입니다.
> - **개체 무결성(Entity Integrity)**: 기본키를 구성하는 속성은 NULL 값이나 중복값을 가질 수 없습니다. (1번 - 올바른 설명)
> - **참조 무결성(Referential Integrity)**: 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 일치해야 합니다. (2번은 사용자 정의 무결성의 설명)
> - **도메인 무결성(Domain Integrity)**: 특정 속성의 값이 그 속성에 정의된 도메인 범위에 속해야 합니다. (3번은 참조 무결성의 설명)
> - **사용자 정의 무결성(User-Defined Integrity)**: 사용자가 정의한 비즈니스 규칙을 만족해야 합니다. (4번은 도메인 무결성의 설명)
> 선택지 2~4번은 설명이 서로 뒤바뀌어 있으므로, 1번이 유일하게 올바른 설명입니다.

---

**52번.** 다음 중 데이터베이스 키(Key)의 정의와 특징이 바르게 연결된 것은?

1. **슈퍼키(Super Key): 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는 속성 또는 속성들의 집합이다.** ✅ 정답 / 입력한 답
2. 기본키(Primary Key): 후보키 중에서 특별히 선정된 키로, 중복된 값을 가질 수 있으며 상황에 따라 널(NULL) 값을 허용한다.
3. 대체키(Alternate Key): 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말하며, 유일성은 만족하지만 최소성은 만족하지 않는다.
4. 외래키(Foreign Key): 하나의 릴레이션 내에서 각 튜플을 유일하게 식별할 수 있는 속성으로, 반드시 자기 자신의 릴레이션 내에서만 정의되어야 한다.

> 💡 **해설:** 데이터베이스 키의 종류와 특성을 구분하는 문제입니다.
> - **슈퍼키(Super Key)**: 유일성만 만족, 최소성은 만족하지 않아도 됩니다. (1번 - 올바른 설명)
> - **기본키(Primary Key)**: 후보키 중 선정된 키로, NULL과 중복값 모두 불가합니다. (2번 설명은 틀림)
> - **대체키(Alternate Key)**: 후보키 중 기본키를 제외한 나머지로, 유일성과 최소성 모두 만족합니다. (3번에서 '최소성 만족하지 않는다'가 틀림)
> - **외래키(Foreign Key)**: 다른 릴레이션의 기본키를 참조하는 속성입니다. (4번 설명은 후보키에 대한 설명)
> 키의 특성: 후보키 = 유일성 + 최소성, 슈퍼키 = 유일성만 만족

---

**53번.** 다음 중 트랜잭션의 상태(Transaction State)에 대한 설명으로 가장 옳지 않은 것은?

1. 활동(Active): 트랜잭션이 시작되어 현재 실행 중인 상태를 의미한다.
2. 완료(Committed): 트랜잭션이 성공적으로 종료되어 연산 결과를 데이터베이스에 최종적으로 반영(Commit)한 상태이다.
3. **부분 완료(Partially Committed): 트랜잭션의 마지막 연산 바로 직전의 상태로, Commit 연산이 실행되기 전의 상태이다.** ✅ 정답 / 입력한 답
4. 철회(Aborted): 트랜잭션 수행 중 오류가 발생하여 수행이 중단되고, 실행 전 상태로 돌아가기 위해 Rollback 연산을 수행한 상태이다.

> 💡 **해설:** 트랜잭션 상태 전이에 관한 문제입니다.
> 3번 설명이 틀린 이유: **부분 완료(Partially Committed)**는 트랜잭션의 마지막 연산이 실행된 **직후**의 상태입니다. 즉, 마지막 연산 수행은 완료되었지만 아직 Commit이 실행되기 전의 상태를 말합니다. 문제에서 "마지막 연산 바로 직전"이라고 한 것이 오류입니다.
> - Active(활동) → Partially Committed(부분 완료) → Committed(완료) 순으로 전이되며,
> - 오류 발생 시 Active 또는 Partially Committed 상태에서 Failed(실패) → Aborted(철회)로 전이됩니다.

---

**54번.** 트랜잭션의 특성 중 틀린 것은?

1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
2. **둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 있다.** ✅ 정답 / 입력한 답
3. 트랜잭션에 의해서 생성된 결과는 계속 유지되어야 한다.
4. 트랜잭션의 연산을 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

> 💡 **해설:** 트랜잭션의 ACID 특성에 관한 문제입니다.
> - 1번: **일관성(Consistency)** - 트랜잭션 수행 전후 데이터베이스 상태가 일관성을 유지해야 합니다. (올바른 설명)
> - 2번: **격리성(Isolation)** - 병행 실행 시 다른 트랜잭션이 끼어들 수 없어야 합니다. "끼어들 수 있다"는 표현이 틀린 설명입니다. (정답)
> - 3번: **지속성(Durability)** - 성공적으로 완료된 트랜잭션의 결과는 영구히 보존됩니다. (올바른 설명)
> - 4번: **원자성(Atomicity)** - 트랜잭션 연산은 전부 실행되거나 전혀 실행되지 않아야 합니다(All or Nothing). (올바른 설명)

---

**55번.** 외래키(Foreign Key)에 대한 설명으로 옳지 않은 것은?

1. **외래키는 하나의 릴레이션에 존재하는 후보키들 중에서 기본키를 제외한 나머지 후보키들을 의미한다.** ✅ 정답 / 입력한 답
2. 외래키는 현실 세계에서 존재하는 개체타입들 간의 관계를 표현하는데 중요한 역할을 수행한다.
3. 관계형 데이터 모델에서 한 릴레이션의 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션간에 참조 관계를 표현하는 중요한 도구이다.
4. 외래키를 포함하는 릴레이션이 참조하는 릴레이션이 되고, 대응하는 기본키를 포함하는 릴레이션이 참조 릴레이션이 된다.

> 💡 **해설:** 외래키(Foreign Key)의 정의에 관한 문제입니다.
> 1번 설명은 **대체키(Alternate Key)**의 정의입니다. 대체키는 후보키 중에서 기본키를 제외한 나머지 후보키들을 말합니다.
> **외래키(Foreign Key)**는 한 릴레이션의 속성이 다른 릴레이션의 기본키를 참조하는 속성(또는 속성들의 집합)입니다. 외래키는 NULL이거나 참조하는 릴레이션의 기본키 값과 같아야 합니다(참조 무결성).

---

**56번.** 정규화에 관한 설명으로 옳지 않은 것은?

1. 릴레이션 R의 도메인들의 값이 원자값만을 가지면 릴레이션 R은 제1정규형에 해당된다.
2. **릴레이션 R이 제2정규형을 만족하고, 결정자 이면서 후보키가 아닌 것을 제거하면 제3정규형에 해당된다.** ✅ 정답 / 입력한 답
3. 릴레이션 R이 제1정규형을 만족하면서, 키가 아닌 모든 속성들이 기본키에 완전 함수 종속이면 릴레이션 R은 제2정규형에 해당된다.
4. 정규형들은 차수가 높아질수록(제1정규형→제5정규형) 만족시켜야 할 제약조건이 많아진다.

> 💡 **해설:** 정규화 단계에 관한 문제입니다.
> 2번 설명은 **BCNF(Boyce-Codd Normal Form)**의 정의입니다. BCNF는 모든 결정자가 후보키여야 하는 조건으로, "결정자이면서 후보키가 아닌 것을 제거"하는 것은 BCNF 달성 방법입니다.
> **제3정규형(3NF)**은 제2정규형을 만족하면서, 기본키가 아닌 모든 속성이 기본키에 대해 **이행적 함수 종속(Transitive Functional Dependency)**을 갖지 않는 것입니다. (A→B→C 에서 A→C를 제거)
> - 1NF: 원자값만 존재
> - 2NF: 1NF + 부분 함수 종속 제거 (완전 함수 종속)
> - 3NF: 2NF + 이행적 함수 종속 제거
> - BCNF: 3NF + 모든 결정자가 후보키

---

**57번.** 관계 해석에 대한 설명으로 틀린 것은? ❌ 오답

1. 튜플 관계 해석과 도메인 관계 해석이 있다.
2. **질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시해야 하는 절차적인 언어이다.** ✅ 정답
3. ~~릴레이션을 정의하는 방법을 제공한다.~~ ← 입력한 답
4. 수학의 프레디킷 해석(Predicate Calculus)에 기반을 두고 있다.

> ❌ 오답: 입력=③릴레이션을 정의하는 방법을 제공한다. / 정답=②절차적인 언어이다.

> 💡 **해설:** 관계 해석(Relational Calculus)의 특성에 관한 문제입니다.
> **관계 해석은 비절차적(Non-Procedural) 언어**입니다. 원하는 결과가 무엇인지(What)만 기술하고, 어떻게 구하는지(How)는 명시하지 않습니다. 2번에서 "수행해야 할 연산의 순서를 명시해야 하는 절차적인 언어"라는 설명이 틀린 부분입니다.
> 반면 **관계 대수(Relational Algebra)**는 절차적 언어로, 연산의 순서를 명시합니다.
> - 관계 해석: 비절차적, 수학의 프레디킷 해석 기반, 튜플 관계 해석/도메인 관계 해석으로 구분
> - ③번 "릴레이션을 정의하는 방법을 제공한다"는 관계 해석의 실제 기능으로 올바른 설명입니다.

---

**58번.** 물리 데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?

1. 범위 분할(Range Partitioning)
2. 해시 분할(Hash Partitioning)
3. 조합 분할(Composite Partitioning)
4. **유닛 분할(Unit Processing)** ✅ 정답 / 입력한 답

> 💡 **해설:** 데이터베이스 파티션 유형에 관한 문제입니다.
> 표준 파티션 유형으로는 다음이 있습니다:
> - **범위 분할(Range Partitioning)**: 지정한 열의 값 범위를 기준으로 분할 (예: 날짜 범위)
> - **해시 분할(Hash Partitioning)**: 해시 함수를 적용한 결과값으로 분할
> - **목록 분할(List Partitioning)**: 지정한 열의 특정 값 목록을 기준으로 분할
> - **조합 분할(Composite Partitioning)**: 두 가지 이상의 분할 방법을 조합하여 사용
> - **라운드 로빈 분할(Round-Robin Partitioning)**: 균등하게 순환하며 분할
> **유닛 분할(Unit Processing)**은 파티션 유형으로 존재하지 않습니다.

---

**59번.** 다음 SQL 문에서 ( ) 안에 들어갈 내용으로 옳은 것은?
```sql
UPDATE 인사급여 ( ) 호봉=15 WHERE 성명='홍길동';
```
❌ 오답

1. **SET** ✅ 정답
2. ~~FROM~~ ← 입력한 답
3. INTO
4. IN

> ❌ 오답: 입력=②FROM / 정답=①SET

> 💡 **해설:** SQL UPDATE 문법에 관한 문제입니다.
> UPDATE 문의 기본 문법: `UPDATE 테이블명 SET 열명=값 [WHERE 조건]`
> - `UPDATE`: 데이터 수정 명령어
> - `SET`: 수정할 열과 값을 지정하는 키워드
> - `WHERE`: 수정 대상 행을 지정하는 조건절
> FROM은 SELECT문에서 테이블을 지정할 때 사용하는 키워드이고, INTO는 INSERT문에서 사용합니다.

---

**60번.** 참조 무결성을 유지하기 위하여 DROP 문에서 부모 테이블의 항목 값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?

1. CLUSTER
2. **CASCADE** ✅ 정답 / 입력한 답
3. SET-NULL
4. RESTRICTED

> 💡 **해설:** 참조 무결성 제약 조건의 삭제/갱신 옵션에 관한 문제입니다.
> 외래키의 참조 무결성 옵션:
> - **CASCADE**: 부모 테이블의 행이 삭제/변경되면 자식 테이블의 해당 행도 자동으로 삭제/변경됩니다.
> - **SET NULL**: 부모 테이블의 행이 삭제/변경되면 자식 테이블의 해당 외래키 값을 NULL로 설정합니다.
> - **RESTRICT(RESTRICTED)**: 자식 테이블에 참조하는 행이 있으면 부모 테이블의 삭제/변경을 거부합니다.
> - **NO ACTION**: 참조 무결성을 위반하는 작업을 허용하지 않습니다.
> CLUSTER는 인덱스 관련 옵션으로 참조 무결성과 관련이 없습니다.

---

**61번.** C언어에서 사용할 수 없는 변수명은?

1. student2019
2. **text-color** ✅ 정답 / 입력한 답
3. _korea
4. amount

> 💡 **해설:** C언어 식별자(변수명) 명명 규칙에 관한 문제입니다.
> C언어 식별자 규칙:
> - 영문자(a-z, A-Z), 숫자(0-9), 언더스코어(_)만 사용 가능
> - 숫자로 시작 불가
> - 키워드(예약어) 사용 불가
> - 대소문자 구분
> `text-color`에서 하이픈(-)은 C언어에서 뺄셈 연산자로 해석되므로, `text-color`는 변수명으로 사용할 수 없습니다. 이 표현식은 `text - color` (text에서 color를 빼는 연산)으로 해석됩니다.

---

**62번.** 다음 c언어 프로그램이 실행되었을 때, 실행 결과는?
```c
#include <stdio.h>
int main(int argc, char *argv[ ]) {
    int a = 1, b= 2
    int r = (++a, a++, b++);
    printf("%d", r);
    return 0;
}
```

1. 1
2. **2** ✅ 정답 / 입력한 답
3. 3
4. 4

> 💡 **해설:** C언어 쉼표(comma) 연산자와 전위/후위 증가 연산자에 관한 문제입니다.
> 쉼표 연산자는 왼쪽부터 순서대로 각 표현식을 평가하고, 마지막 표현식의 값을 반환합니다.
> `r = (++a, a++, b++)` 실행 과정:
> 1. `++a`: a가 1→2로 증가 (전위 연산, a=2)
> 2. `a++`: 현재 a=2를 읽고 a가 2→3으로 증가 (후위 연산, a=3). 이 값(2)은 쉼표 연산자에 의해 버려짐
> 3. `b++`: 현재 b=2를 읽고 b가 2→3으로 증가 (후위 연산). 이 값(2)이 r에 대입됨
> 따라서 `r = 2`, `printf("%d", r)`의 출력은 **2**

---

**63번.** 파이썬에서 여러 자료를 한 번에 저장하는 자료형으로만 묶인 것은?

1. int, float, str
2. float, bool, list
3. bool, tuple, set
4. **list, set, tuple** ✅ 정답 / 입력한 답

> 💡 **해설:** 파이썬 컨테이너(자료 모음) 자료형에 관한 문제입니다.
> 파이썬의 단일 값 자료형: `int`, `float`, `str`, `bool`
> 파이썬의 컨테이너(여러 자료 저장) 자료형:
> - **list**: 순서 있음, 변경 가능 (mutable), 중복 허용 예) `[1, 2, 3]`
> - **tuple**: 순서 있음, 변경 불가 (immutable), 중복 허용 예) `(1, 2, 3)`
> - **set**: 순서 없음, 변경 가능, 중복 불허 예) `{1, 2, 3}`
> - **dict**: 키-값 쌍, 변경 가능 예) `{'a': 1}`
> `str`은 문자들의 시퀀스이지만 여러 자료형을 저장하는 것이 아닌 문자열 자료형으로 분류합니다.

---

**64번.** 3개의 프레임을 수용할 수 있는 주기억 장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우, 페이지 결함의 발생 횟수는?

페이지 참조 순서 : 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0

1. 13
2. **14** ✅ 정답 / 입력한 답
3. 15
4. 20

> 💡 **해설:** FIFO(First In First Out) 페이지 교체 알고리즘에 관한 문제입니다.
> FIFO는 가장 오래된 페이지를 교체합니다. 프레임 수 = 3
>
> | 참조 | 프레임 상태 | 결함 |
> |------|------------|------|
> | 7 | [7] | ○ |
> | 0 | [7,0] | ○ |
> | 1 | [7,0,1] | ○ |
> | 2 | [0,1,2] | ○ (7 교체) |
> | 0 | [0,1,2] | - |
> | 3 | [1,2,3] | ○ (0 교체) |
> | 0 | [2,3,0] | ○ (1 교체) |
> | 4 | [3,0,4] | ○ (2 교체) |
> | 2 | [0,4,2] | ○ (3 교체) |
> | 3 | [4,2,3] | ○ (0 교체) |
> | 0 | [2,3,0] | ○ (4 교체) |
> | 3 | [2,3,0] | - |
> | 2 | [2,3,0] | - |
> | 1 | [3,0,1] | ○ (2 교체) |
> | 2 | [0,1,2] | ○ (3 교체) |
> | 0 | [0,1,2] | - |
> | 1 | [0,1,2] | - |
> | 7 | [1,2,7] | ○ (0 교체) |
> | 0 | [2,7,0] | ○ (1 교체) |
>
> 총 페이지 결함 횟수: **14회**

---

**65번.** 교착상태 발생의 필요 충분 조건이 아닌 것은?

1. 상호배제(Mutual Exclusion)
2. 점유와 대기(Hold and Wait)
3. 환형 대기(Circular Wait)
4. **선점(Preemption)** ✅ 정답 / 입력한 답

> 💡 **해설:** 교착상태(Deadlock) 발생의 필요 조건(코프만 조건)에 관한 문제입니다.
> 교착상태 발생의 4가지 필요 충분 조건:
> 1. **상호배제(Mutual Exclusion)**: 자원은 한 번에 하나의 프로세스만 사용 가능
> 2. **점유와 대기(Hold and Wait)**: 자원을 점유한 채로 다른 자원을 기다림
> 3. **비선점(Non-Preemption)**: 점유 중인 자원을 강제로 빼앗을 수 없음
> 4. **환형 대기(Circular Wait)**: 프로세스들이 원형으로 서로의 자원을 기다림
> **선점(Preemption)**이 가능하면 교착상태를 방지할 수 있습니다. 교착상태 조건은 **비선점**이며, 선점은 교착상태 조건이 아닙니다.

---

**66번.** TCP/IP 네트워크에서 IP 주소를 MAC 주소로 변환하는 프로토콜은?

1. UDP
2. **ARP** ✅ 정답 / 입력한 답
3. TCP
4. ICMP

> 💡 **해설:** 주소 변환 프로토콜에 관한 문제입니다.
> - **ARP(Address Resolution Protocol)**: IP 주소 → MAC 주소로 변환
> - **RARP(Reverse ARP)**: MAC 주소 → IP 주소로 변환
> - **ICMP(Internet Control Message Protocol)**: 인터넷 제어 메시지 프로토콜, 오류 보고 및 진단(ping)
> - **UDP(User Datagram Protocol)**: 비연결형 전송 계층 프로토콜
> - **TCP(Transmission Control Protocol)**: 연결형 전송 계층 프로토콜
> ARP는 네트워크 계층(IP)에서 데이터링크 계층(MAC)으로 주소를 변환하여 실제 통신이 가능하게 합니다.

---

**67번.** IP 주소와 호스트 이름 간의 변환을 제공하는 시스템은?

1. **DNS** ✅ 정답 / 입력한 답
2. NFS
3. Router
4. Modem

> 💡 **해설:** 네트워크 서비스에 관한 문제입니다.
> - **DNS(Domain Name System)**: 도메인 이름(호스트 이름)을 IP 주소로 변환(정방향) 또는 IP 주소를 도메인 이름으로 변환(역방향)하는 계층적 분산 데이터베이스 시스템입니다. 기본 포트: UDP 53번
> - **NFS(Network File System)**: 네트워크를 통해 파일 시스템을 공유하는 시스템
> - **Router**: 네트워크 간 패킷을 전달하는 장비
> - **Modem**: 디지털 신호를 아날로그 신호로 변환(또는 그 반대)하는 장비

---

**68번.** 다음 중 프로토콜의 포트 번호가 올바르지 않은 것은?

1. TFTP - UDP 69
2. SNMP - UDP 161
3. **RPC - TCP 112** ✅ 정답 / 입력한 답
4. TELNET - TCP 23

> 💡 **해설:** 주요 프로토콜 포트 번호에 관한 문제입니다.
> **RPC(Remote Procedure Call)**의 표준 포트 번호는 **111번** (TCP/UDP)입니다. 문제에서 112번이라고 한 것이 틀린 내용입니다.
> 주요 포트 번호 정리:
> - FTP: TCP 20(데이터), 21(제어)
> - SSH: TCP 22
> - TELNET: TCP 23
> - SMTP: TCP 25
> - DNS: UDP 53
> - HTTP: TCP 80
> - SNMP: UDP 161
> - TFTP: UDP 69
> - RPC: TCP/UDP 111

---

**69번.** 다음 중 C Class에 속하는 IP Address는?

1. **200.168.30.1** ✅ 정답 / 입력한 답
2. 10.3.2.1
3. 225.2.4.1
4. 172.16.98.3

> 💡 **해설:** IP 주소 클래스 구분에 관한 문제입니다.
> IP 주소 클래스는 첫 번째 옥텟(8비트) 값으로 구분합니다:
> - **Class A**: 0~127 (예: 10.3.2.1 → A 클래스)
> - **Class B**: 128~191 (예: 172.16.98.3 → B 클래스)
> - **Class C**: 192~223 (예: 200.168.30.1 → C 클래스) ← 정답
> - **Class D**: 224~239 (예: 225.2.4.1 → D 클래스, 멀티캐스트용)
> - **Class E**: 240~255 (예약)
> 200은 192~223 범위에 해당하므로 Class C입니다.

---

**70번.** 빈 기억 공간에 크기가 20KB, 16KB, 8KB, 40KB일 때 기억 장치 배치 전략으로 "Best Fit"을 사용하여 17KB의 프로그램을 적재할 경우 내부 단편화의 크기는 얼마인가?

1. **3KB** ✅ 정답 / 입력한 답
2. 23KB
3. 64KB
4. 67KB

> 💡 **해설:** 메모리 배치 전략(Best Fit)에 관한 문제입니다.
> 기억 장치 배치 전략:
> - **First Fit(최초 적합)**: 수용 가능한 첫 번째 공간에 배치
> - **Best Fit(최적 적합)**: 수용 가능한 공간 중 가장 작은 공간에 배치 → 남는 공간(단편화) 최소화
> - **Worst Fit(최악 적합)**: 수용 가능한 공간 중 가장 큰 공간에 배치
>
> 17KB 프로그램을 Best Fit으로 배치:
> - 20KB: 17KB 수용 가능, 남는 공간 3KB
> - 16KB: 17KB 수용 불가 (너무 작음)
> - 8KB: 17KB 수용 불가 (너무 작음)
> - 40KB: 17KB 수용 가능, 남는 공간 23KB
>
> Best Fit → 남는 공간이 가장 작은 **20KB** 공간 선택
> 내부 단편화 = 20KB - 17KB = **3KB**

---

**71번.** JAVA의 예외(Exception)와 관련된 설명으로 틀린 것은?

1. **문법 오류로 인해 발생한 것** ✅ 정답 / 입력한 답
2. 오동작이나 결과에 악영향을 미칠 수 있는 실행시간 동안에 발생한 오류
3. 배열의 인덱스가 그 범위를 넘어서는 경우 발생하는 오류
4. 존재하지 않는 파일을 읽으려고 하는 경우에 발생하는 오류

> 💡 **해설:** Java 예외(Exception)의 특성에 관한 문제입니다.
> **Java 예외(Exception)**는 프로그램 **실행 중(Runtime)**에 발생하는 오류 상황입니다.
> **문법 오류(Syntax Error)**는 컴파일 타임에 발견되는 오류로, Java 예외가 아닌 **컴파일 에러**입니다.
> Java 예외의 예시:
> - `ArrayIndexOutOfBoundsException`: 배열 인덱스 초과 (3번)
> - `FileNotFoundException`: 파일 없음 (4번)
> - `NullPointerException`: null 참조
> - `ClassCastException`: 잘못된 형 변환
> - `ArithmeticException`: 0으로 나누기
> Java 예외 계층: `Throwable` → `Error` / `Exception` → `RuntimeException` / `CheckedException`

---

**72번.** SSH(Secure Shell)에 대한 설명으로 틀린 것은?

1. **SSH의 기본 네트워크 포트는 220번을 사용한다.** ✅ 정답 / 입력한 답
2. 전송되는 데이터는 암호화된다.
3. 키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 한다.
4. 서로 연결되어 있는 컴퓨터 간 원격 명령 실행이나 쉘 서비스 등을 수행한다.

> 💡 **해설:** SSH(Secure Shell) 프로토콜에 관한 문제입니다.
> **SSH의 기본 포트 번호는 22번**입니다. 220번이라는 설명이 틀린 내용입니다.
> SSH의 특징:
> - 기본 포트: **TCP 22번**
> - 암호화된 보안 원격 접속 프로토콜 (Telnet의 보안 버전)
> - 전송되는 모든 데이터가 암호화됨
> - 공개키 기반 인증: 클라이언트의 공개키(Public Key)를 서버의 `~/.ssh/authorized_keys`에 등록
> - 원격 명령 실행, 파일 전송(SCP, SFTP), 터널링 기능 지원

---

**73번.** 오류 제어에 사용되는 자동반복 요청방식(ARQ)이 아닌 것은? ❌ 오답

1. Stop-and-wait ARQ
2. Go-back-N ARQ
3. ~~Selective-Repeat ARQ~~ ← 입력한 답
4. **Non-Acknowledge ARQ** ✅ 정답

> ❌ 오답: 입력=③Selective-Repeat ARQ / 정답=④Non-Acknowledge ARQ

> 💡 **해설:** ARQ(Automatic Repeat reQuest) 방식의 종류에 관한 문제입니다.
> 표준 ARQ 방식 3가지:
> - **Stop-and-Wait ARQ**: 프레임 하나를 전송하고 ACK를 받을 때까지 대기. 단순하지만 효율 낮음
> - **Go-Back-N ARQ**: 오류 발생 프레임부터 N개 모두 재전송
> - **Selective-Repeat ARQ (선택적 반복)**: 오류 발생 프레임만 선택하여 재전송. 효율이 가장 높음
> **Non-Acknowledge ARQ**는 표준 ARQ 방식으로 존재하지 않는 개념입니다.
> Selective-Repeat ARQ는 실제 존재하는 방식이므로 정답이 될 수 없습니다.

---

**74번.** 자바 프로그램이 실행되었을 때, 실행 결과는?
```java
public class Main{
    public static void main(String[] args){
        int[] c = {500, 100, 50, 10};
        int m = 6790;
        int a = 0;
        for (int i = 0; i < c.length; i++){
            int cnt = m/c[i]
            a += cnt;
            m = m - cnt*c[i];
        }
        System.out.printf("%d", a);
    }
}
```

1. 4
2. **20** ✅ 정답 / 입력한 답
3. 420
4. 894

> 💡 **해설:** Java 정수 나눗셈과 반복문에 관한 문제입니다. 거스름돈 계산 알고리즘입니다.
> 초기값: m=6790, a=0
>
> | i | c[i] | cnt = m/c[i] | a += cnt | m -= cnt*c[i] |
> |---|------|--------------|----------|----------------|
> | 0 | 500 | 6790/500=13 | a=13 | m=6790-6500=290 |
> | 1 | 100 | 290/100=2 | a=15 | m=290-200=90 |
> | 2 | 50 | 90/50=1 | a=16 | m=90-50=40 |
> | 3 | 10 | 40/10=4 | a=20 | m=40-40=0 |
>
> 최종 출력: **20**

---

**75번.** IPv6의 주소체계로 거리가 먼 것은?

1. 유니캐스트
2. 애니캐스트
3. **브로드캐스트** ✅ 정답 / 입력한 답
4. 멀티캐스트

> 💡 **해설:** IPv6 주소 유형에 관한 문제입니다.
> **IPv6의 3가지 주소 유형**:
> - **유니캐스트(Unicast)**: 단일 인터페이스(1:1 통신)
> - **애니캐스트(Anycast)**: 여러 인터페이스 중 가장 가까운 하나에게 전달(1:1, 그룹 중 최단 경로)
> - **멀티캐스트(Multicast)**: 특정 그룹의 모든 인터페이스에 전달(1:N)
>
> **브로드캐스트(Broadcast)**는 **IPv4에서만 지원**되는 주소 유형입니다. IPv6에서는 브로드캐스트를 사용하지 않으며, 그 기능을 멀티캐스트가 대체합니다.

---

**76번.** C언어에서 비트 논리 연산자에 해당하지 않는 것은?

1. ^
2. **?** ✅ 정답 / 입력한 답
3. &
4. ~

> 💡 **해설:** C언어의 비트 연산자 종류에 관한 문제입니다.
> C언어의 비트(Bitwise) 연산자:
> - `&`: 비트 AND
> - `|`: 비트 OR
> - `^`: 비트 XOR (1번 - 비트 연산자)
> - `~`: 비트 NOT (1의 보수) (4번 - 비트 연산자)
> - `<<`: 왼쪽 시프트
> - `>>`: 오른쪽 시프트
>
> **`?`**는 **삼항(조건) 연산자**(`조건 ? 참_값 : 거짓_값`)로, 비트 연산자가 아닙니다.

---

**77번.** C언어에서 두 개의 논릿값 중 하나라도 참이면 1을, 모두 거짓이면 0을 반환하는 연산자는?

1. **||** ✅ 정답 / 입력한 답
2. &&
3. **
4. !=

> 💡 **해설:** C언어의 논리 연산자에 관한 문제입니다.
> 하나라도 참이면 1을 반환 → 논리 OR 연산
> - **`||`**: 논리 OR - 피연산자 중 하나라도 참(0이 아님)이면 1, 모두 거짓(0)이면 0 반환 (정답)
> - **`&&`**: 논리 AND - 두 피연산자 모두 참이면 1, 하나라도 거짓이면 0 반환
> - **`!=`**: 부등 비교 연산자 - 두 값이 다르면 1, 같으면 0 반환
> - `**`는 C언어에서 지원하지 않는 연산자입니다 (파이썬의 거듭제곱 연산자)

---

**78번.** 객체지향 프로그래밍의 장점으로 거리가 먼 것은? ❌ 오답

1. ~~자연적인 모델링이 가능하다.~~ ← 입력한 답
2. 소프트웨어의 재사용율이 높아진다.
3. 소프트웨어의 유지보수성이 향상된다.
4. **실행속도가 빨라진다.** ✅ 정답

> ❌ 오답: 입력=①자연적인 모델링이 가능하다. / 정답=④실행속도가 빨라진다.

> 💡 **해설:** 객체지향 프로그래밍(OOP)의 장단점에 관한 문제입니다.
> **객체지향 프로그래밍의 장점**:
> - 자연적인 모델링이 가능 (현실 세계를 객체로 모델링)
> - 소프트웨어 재사용성 향상 (클래스, 상속)
> - 유지보수성 향상 (캡슐화, 모듈화)
> - 대형 프로젝트에 적합
>
> **객체지향 프로그래밍의 단점**:
> - **실행 속도가 느림** (절차지향에 비해 오버헤드 발생 - 동적 바인딩, 가상 함수 테이블 등)
> - 설계가 복잡함
> - 처리 속도가 절차적 언어보다 느릴 수 있음
>
> 따라서 "실행속도가 빨라진다"는 객체지향의 단점에 해당하여 장점이 아닙니다.

---

**79번.** 다음 C언어 프로그램이 실행되었을 때의 결과는?
```c
#include <stdio.h>
int main(int argc, char *argv[]){
    int a = 4;
    int b = 7;
    int c = a | b;
    printf("%d", c);
    return 0;
}
```

1. 3
2. 4
3. **7** ✅ 정답 / 입력한 답
4. 10

> 💡 **해설:** C언어의 비트 OR 연산에 관한 문제입니다.
> `a | b` = 비트 OR 연산
> - a = 4 → 이진수: `0100`
> - b = 7 → 이진수: `0111`
> - a | b → `0100` | `0111` = `0111` = 7
>
> 비트 OR는 대응하는 비트 중 하나라도 1이면 1을 반환합니다.
> 따라서 `c = 7`, `printf("%d", c)` 출력: **7**
> (참고로 `a & b` = `0100` & `0111` = `0100` = 4)

---

**80번.** 다음 Python 프로그램의 실행 결과가 [실행 결과]와 같을 때, 빈칸에 적합한 것은?
```python
x = 20
if x == 10:
    print('10')
( ) x == 20:
    print('20')
else:
    print('other')
```
[실행 결과] 20

1. either
2. **elif** ✅ 정답 / 입력한 답
3. else if
4. else

> 💡 **해설:** Python 조건문 문법에 관한 문제입니다.
> Python의 다중 조건문 구조:
> ```python
> if 조건1:
>     실행문1
> elif 조건2:      # else if의 Python 축약 키워드
>     실행문2
> else:
>     실행문3
> ```
> - `elif`: Python에서 "else if"를 의미하는 키워드 (정답)
> - `else if`: Java, C, JavaScript 등에서 사용하는 문법 (Python에서는 사용 불가)
> - `either`: 존재하지 않는 키워드
> - `else`: 조건 없이 나머지 경우를 처리 (elif처럼 조건식을 가질 수 없음)
> x=20이고 `elif x == 20` 조건이 참이므로 '20'이 출력됩니다.

---

## 오답 정리 (51번~80번)

| 번호 | 주제 | 입력한 답 | 정답 |
|------|------|----------|------|
| 57번 | 관계 해석 | ③릴레이션을 정의하는 방법을 제공한다. | ②절차적인 언어이다. |
| 59번 | SQL UPDATE 구문 | ②FROM | ①SET |
| 73번 | ARQ 방식 | ③Selective-Repeat ARQ | ④Non-Acknowledge ARQ |
| 78번 | 객체지향 프로그래밍 장점 | ①자연적인 모델링이 가능하다. | ④실행속도가 빨라진다. |
